      PROGRAM FEAP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- FINITE ELEMENT ANALYSIS PROGRAM (FEAP) FOR SOLUTION OF GENERAL
C---- PROBLEM CLASSES USING THE FINITE ELEMENT METHOD.  PROBLEM SIZE
C---- IS CONTROLLED BY THE DIMENSION OF BLANK COMMON AND VALUE OF MAX
C---- AS SET IN MAIN PROGRAM. ALL ARRAYS MUST RESIDE IN CENTRAL MEMORY.
C
C---- PROGRAMMED BY PROF. R.L. TAYLOR, DEPARTMENT OF CIVIL ENGINEERING,
C---- UNIVERSITY OF CALIFORNIA, BERKELEY, CA 94720 (USA)
C
C---- CONVERTED, REVISED AND EXTENDED BY M. ORTIZ, ENGINEERING
C---- DIVISION, BROWN UNIVERSITY, PROVIDENCE, RI 02912 (USA)
C
C---- SET PROGRAM CAPACITY
      PARAMETER (MDIM = 25000000)
      PARAMETER (MDIMAV=25000000)
C
      INTEGER*4 CPUTIME
C     INTEGER CPUTIME
C     COMMON M(MDIM)
      COMMON /MAINN/ M(25000000)
      COMMON /PSIZE/ MAX
      COMMON /TAPE/ NMAT,NRED,NPVT,NELSTF,NBFGS,LDUMP,LREST
     1 ,LSEFF,LDISP,LPRTS,LRESF,LSMTH
      COMMON /BLOCK/ MAXAV,LBLOK,NBLOK,MAXC,NELCOR
      COMMON /CPU/ CPUTIME
C
      MAX = MDIM
      MAXAV=MDIMAV
C---- TAPE UNITS:
      LDUMP=9
      NMAT=14
      NBFGS=15
      NRED=16
      NPVT=17
      NELSTF=18
      LREST=19
      LSEFF=22
      LDISP=23
      LPRTS=24
      LRESF=25
      LSMTH=26
C
      OPEN(UNIT=5,FILE='fpin.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=6,FILE='fpout.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=9,FILE='fpdump.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=14,FILE='fpmat.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=15,FILE='fpbfgs.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=16,FILE='fpred.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=17,FILE='fppvt.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=18,FILE='fpelst.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=19,FILE='fprest.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=22,FILE='fpseff.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=23,FILE='fpdisp.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=24,FILE='fpprts.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=10,FILE='fpjint.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=25,FILE='fpresf.dat',FORM='FORMATTED',
     1 ACCESS='SEQUENTIAL')
      OPEN(UNIT=26,FILE='fpsmth.dat',FORM='UNFORMATTED',
     1 ACCESS='SEQUENTIAL')
C---- INITIALIZE CPU TIMER (VAX-VMS)
C     CALL LIB$INIT_TIMER(CPUTIME)
C
C---- CALL CONTROL SUBROUTINE
      CALL PCONTR
C
C---- TURN OFF CPU TIMER
C     CALL LIB$FREE_TIMER(CPUTIME)
C
      STOP
      END
      SUBROUTINE PCONTR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL PRT,MAC
      CHARACTER*4 TITL(20),WD(7)
      CHARACTER*8 HEAD
      CHARACTER*1 O
      COMMON /CHEAD/ O,HEAD(20)
      COMMON /CDATA/ NUMNP,NUMEL,NUMMAT,NEN,NEQ,IPR,
     1 NSDM,NQDM,NQUAD
      COMMON /MDATA/ NN,N0,N1,N2,N3,N301,N302,N4,N5,N6,N7,N8,N9,N91,
     1 N10,N11,N12,N13,N14,N15,N16,N161,N162,N163,N164,N165,N166,
     1 N17,N18,N181,N182,N183,N184,N185,N186,N19,N20
      COMMON/PLONG/ KMAX
      COMMON/PRINT/ PRT
      COMMON/AUTSTP/ IAUTO
      COMMON /CNTAC/ CP(2,50),BET(50),DEL(2,50),IC(50),IM(100),
     1 IAB(2,50),MSEG(50),NDEST(50),ANG(50),DUSL(2,50),
     1  SMU,DMU,NC,NM,ALP,FRTOL
      COMMON /WEDGE/ NSURF,ISURF(50),CPSURF(2,50),NDSURF(50),
     1  THTSRF,PENSRF
      COMMON /COHES/ NINTND,INTND(2,100),ALPAA,DLTAA,SIGMXX,
     1 XLNTND(100),ANGINT(100),CPINT(2,100),
     2 XLN(100), ISTAT(100)
C     COMMON M(1)
      COMMON /MAINN/ M(25000000)
      COMMON /PTABLE/ NPLD,NDIST,T1,P1,T2,P2
      DATA WD/'FEAP','MACR','STOP','XXXX','XXXX','SAVE','READ'/
C
C---- VARIABLE DEFINITION
C
C---- NUMNP  = NUMBER OF NODAL POINTS
C---- NUMEL  = NUMBER OF ELEMENTS
C---- NUMMAT = NUMBER OF MATERIAL SETS
C---- NDM    = DIMENSION OF AMBIENT SPACE
C---- NDF    = NUMBER OF DEGREES OF FREEDOM PER NODE
C---- NEN    = NUMBER OF NODES PER ELEMENT
C---- NAD    = ADDED SIZE TO ELEMENT MATRICES IN EXCESS OF NDF*NEN
C---- NSDM   = DIMENSION OF STRESS ARRAY
C---- NQDM   = DIMENSION OF INTERNAL VARIABLE ARRAY
C---- NQUAD  = NUMBER OF QUADRATURE POINTS PER ELEMENT
C---- NEQ    = NUMBER OF EQUATIONS OF SYSTEM
C---- IPR    = REAL TO INTEGER WORD LENGTH RATIO
C---- NE     = FIRST FREE STORAGE LOCATION
C---- NST    = DIMENSION OF ELEMENT STIFFNESS MATRIX
C---- NSTR   = DIMENSION OF ELEMENT STRESS ARRAY
C---- NQ     = DIMENSION OF ELEMENT INTERNAL VARIABLE ARRAY
C---- O      = CARRIAGE CONTROL CHARACTER
C---- NPLD   = NUMBER OF PROPORTIONAL LOAD CARDS TO BE READ
C---- NDIST  = NUMBER OF DISTRIBUTED EDGE LOAD CARDS
C---- IAUTO  = 1 IF AUTO STEPPING IS REQUESTED
C----        = 0 IF AUTO STEPPING IS NOT REQUESTED (DEFAULT)
C
C---- INITIALIZE VARIABLES
      KMAX = 0
      MAC = .TRUE.
      O = ' '
      IPR = 2
C     IPR = 1
      NSURF = 0
      NDSURF(1) = 1
      DO 9929 KRJ=2,50
         NDSURF(KRJ)=0
         CPSURF(1,KRJ)=0.D0
         CPSURF(2,KRJ)=0.D0
9929  CONTINUE
      NINTND = 0
      DO 9928 IAG=1,100
      INTND(1,IAG)=0
      INTND(2,IAG)=0
      CPINT(1,IAG) = 0.D0
      CPINT(2,IAG) = 0.D0
9928  CONTINUE
C
C---- WRITE BANNER
      WRITE(6,2000)
C
C---- READ A CARD AND COMPARE FIRST 4 COLUMNS WITH MACRO LIST
1     READ(5,1000) TITL
      IF((TITL(1).EQ.WD(1))) GO TO 100
      IF((TITL(1).EQ.WD(2))) GO TO 200
      IF((TITL(1).EQ.WD(3))) STOP
      IF((TITL(1).EQ.WD(4))) GO TO 150
      III = 1
      IF((TITL(1).EQ.WD(5))) GO TO 125
      IF((TITL(1).EQ.WD(6))) GO TO 300
      IF((TITL(1).EQ.WD(7))) GO TO 400
      GO TO 1
C
C---- MACRO 'FEAP'
C---- READ AND PRINT CONTROL INFORMATION
100   DO 101 I = 1,20
101   HEAD(I) = TITL(I)
      READ(5,1001) NUMNP,NUMEL,NUMMAT,NDM,NDF,NEN,
     1 NSDM,NQDM,NQUAD,NPLD,NDIST,IAUTO,NC
      WRITE(6,2001) HEAD,NUMNP,NUMEL,NUMMAT,NDM,NDF,NEN,
     1 NSDM,NQDM,NQUAD,NPLD,NDIST,IAUTO,NC
      IF(NC.GT.50) THEN
      WRITE(6,2002) NC
      STOP
      END IF
      NSDM = MAX0(NSDM,1)
      NQDM = MAX0(NQDM,1)
      NQUAD= MAX0(NQUAD,1)
C---- SET POINTERS FOR ALLOCATION OF DATA ARRAYS
C
C---- M(1)   -> SOLUTION VECTOR (DR)
C---- M(NN)  -> LOCAL SOLUTION ARRAY (UL)
C---- M(N0)  -> LOCAL NODAL COORDINATES (XL)
C---- M(N1)  -> LOCAL NODAL TEMPERATURES (TL)
C---- M(N2)  -> LOCAL CONNECTIVITY ARRAY (IDL)
C---- M(N3)  -> ELEMENT INTERNAL FORCE VECTOR (P)
C---- M(N301)-> EQUIVALENT DISTRIBUTED LOAD VECTOR (PDIST)
C---- M(N302)-> ELEM #S AND PROP TABLE ID FOR DISTR LOADS (IDIST)
C---- M(N4)  -> ELEMENT STIFFNESS (S)
C---- M(N5)  -> GLOBAL/LOCAL DOF ASSIGNMENT ARRAY (IE)
C---- M(N6)  -> MATERIAL PROPERTIES (D)
C---- M(N7)  -> BOUNDARY CONDITION ARRAY (ID)
C---- M(N8)  -> NODAL COORDINATES (X)
C---- M(N9)  -> CONNECTIVITY ARRAY (IX)
C---- M(91)  -> IDENTIFIER FOR PROP TABLE (IDPROP)
C---- M(N10) -> NODAL FORCES (F)
C---- M(N11) -> NODAL TEMPERATURES (T)
C---- M(N12) -> COLUMN PROFILE ARRAY (JDIAG)
C---- M(N13) -> ELEMENT STRESSES (QUAD AND OUTPUT PTS) (STR)
C---- M(N14) -> ELEMENT STRAINS  (QUAD AND OUTPUT PTS) (EPS)
C---- M(N15) -> ELEMENT INTERNAL VARIABLES (QUAD AND OUTPUT PTS) (Q)
C---- M(N16) -> TOTAL DISPLACEMENTS (B)
C---- M(N161)-> OUT-OF-BALANCE FORCES (DELFRC) & VECTOR USED IN BFGS (VVECT)
C---- M(N162)-> TOTAL DISPLACEMENTS USED DURING LINE SEARCH (UNEW)
C---- M(N163)-> OLD OUT-OF-BALANCE FORCES (OLDFRC)
C---- M(N164)-> VECTOR USED IN BFGS UPDATE (WVECT)
C---- M(N165)-> TABLE OF TIME VALUES (TTABLE)
C---- M(N166)-> TABLE OF PROPORTIONAL LOAD FACTORS (PTABLE)
C---- M(N17) -> NODAL VELOCITIES
C---- M(N18) -> NODAL ACCELERATIONS
C---- M(N181)-> ELEMENT STRESSES OF LAST TIME STEP (STROLD)
C---- M(N182)-> ELEMENT STRAINS  OF LAST TIME STEP (EPSOLD)
C---- M(N183)-> ELEMENT INT VARBLS OF LAST TIME STEP (QOLD)
C---- M(N184)-> NODAL DISPL VECTOR OF LAST TIME STEP (BOLD)
C---- M(N185)-> NODAL VELOCITIES OF LAST TIME STEP  (VELOLD)
C---- M(N186)-> NODAL ACCELERATIONS OF LAST TIME STEP (ACCOLD)
C---- M(N19) -> LOCAL NODAL VELOCITY ARRAY
C---- M(N20) -> LOCAL NODAL ACCELERATION ARRAY
C
      NAD = 0
      NEN1 = NEN + 1
      NST  = NEN*NDF + NAD
      NSTR = NQUAD*NSDM
      NQ   = NQUAD*NQDM
      NPLD1= NPLD
      IF(NPLD.LE.0) NPLD1=1
      NDIST1=NDIST
      IF(NDIST.LE.0) NDIST1=1
      IAUTO1=NUMEL
      IAUTO2=NUMNP*NDF
      IF(IAUTO.EQ.0) THEN
      IAUTO1=1
      IAUTO2=1
      END IF
      NN = 1 + NUMNP*NDF*IPR + NC*NDF*IPR
      N0 = NN + NST*2*IPR
      N1 = N0 + NEN*NDM*IPR
      N2 = N1 + NEN*IPR
      N3 = N2 + NST + MOD(NST,IPR)
C     N4 = N3 + NST*IPR
      N301=N3 + NST*IPR
      N302=N301+NST*IPR*NDIST1
      N4 = N302+NDIST1*2+MOD(NDIST1*2,IPR)
      N5 = N4 + NST*NST*IPR
      N6 = N5 + NUMMAT*7 + MOD(NUMMAT*7,IPR)
      N7 = N6 + 40*NUMMAT*IPR
      N8 = N7 + NDF*NUMNP + MOD(NDF*NUMNP,IPR)
      N9 = N8 + NDM*NUMNP*IPR
C     N10 = N9  + NEN1*NUMEL + MOD(NEN1*NUMEL,IPR)
      N91 = N9  + NEN1*NUMEL + MOD(NEN1*NUMEL,IPR)
      N10 = N91 + NDF*NUMNP  + MOD(NDF*NUMNP,IPR)
      N11 = N10 + NDF*NUMNP*IPR
      N12 = N11 + NUMNP*IPR
      N13 = N12 + NDF*NUMNP + MOD(NDF*NUMNP,IPR)
      N13 = N13 + NC*NDF + MOD(NC*NDF,IPR)
      N14 = N13 + NUMEL*NSTR*IPR
      N15 = N14 + NUMEL*NSTR*IPR
      N16 = N15 + NUMEL*NQ*IPR
C     N17 = N16 + NUMNP*NDF*IPR
      N161= N16 + NUMNP*NDF*IPR
      N162= N161+ NUMNP*NDF*IPR
      N163= N162+ NUMNP*NDF*IPR
      N164= N163+ NUMNP*NDF*IPR
      N165= N164+ NUMNP*NDF*IPR
      N166= N165+ NPLD1*IPR
      N17 = N166+ 7*NPLD1*IPR
      N18 = N17 + NUMNP*NDF*IPR
      N181= N18 + NUMNP*NDF*IPR
      N182= N181+ NSTR*IAUTO1*IPR
      N183= N182+ NSTR*IAUTO1*IPR
      N184= N183+ NQ*IAUTO1*IPR
      N185= N184+ IAUTO2*IPR
      N186= N185+ IAUTO2*IPR
      N19 = N186+ IAUTO2*IPR
      N20 = N19 + NST*IPR
C---- CHECK THAT SUFFICIENT MEMORY EXISTS
      CALL SETMEM(N20)
C---- CALL MESH INPUT SUBROUTINE TO READ AND PRINT ALL MESH DATA
      III = 0
      CALL PMESH(M(N2),M(N0),M(N301),M(N302),M(N4),M(N5),M(N6),
C    1 M(N7),M(N8),M(N9),M(N91),M(N10),M(N11),M(1),M(N13),
     1 M(N7),M(N8),M(N9),M(N91),M(N10),M(N11),M(N16),M(N13),
     2 M(N14),M(N15),M(N17),M(N18),NDF,NDM,NEN1,NSTR,NQ,NST,
     3 NDIST,III,PRT)
C---- ESTATLISH PROFILE OF RESULTING EQUATIONS FOR STIFFNESS, MASS, ETC
      CALL PROFIL(M(N12),M(N7),M(N9),NDF,NEN1,NAD,1,PRT)
      GO TO 1
C
C---- MACRO 'XXXX'
125   GO TO 1
C
C---- MACRO 'XXXX'
150   GO TO 1
C
C---- MACRO 'MACR'
C---- SET UP MACRO PROGRAM FOR EXECUTION
200   CALL PROFIL(M(N12),M(N7),M(N9),NDF,NEN1,NAD,2,PRT)
C---- SET POINTERS FOR SOLUTION ARRAYS * CHECK FOR SUFFICIENT MEMORY
      NE  = N20 + NST*IPR
      CALL SETMEM(NE)
C     IF(MAC) CALL PZERO(M(N16),NEQ)
C---- CALL MACRO SOLUTION MODULE FOR ESTABLISHING SOLUTION ALGORITHM
      CALL PMACR(M(NN),M(N0),M(N1),M(N2),M(N3),M(N301),M(N302),M(N4),
     1 M(N5),M(N6),M(N7),M(N8),M(N9),M(N91),M(N10),M(N11),M(N12),
     2 M(N13),M(N14),M(N15),M(N16),M(N161),M(N162),M(N163),M(N161),
     3 M(N164),M(N165),M(N166),M(1),M(N17),M(N18),M(N181),M(N182),
     4 M(N183),M(N184),M(N185),M(N186),M(N19),M(N20),M(NE),M(1),
     5 NDF,NDM,NEN1,NST,NSTR,NQ,NE,NPLD,NDIST,PRT)
      MAC = .FALSE.
      GO TO 1
C
C---- MACRO 'SAVE'
C---- SAVE THE MESH FOR A RESTART
300   CALL SAVE(TITL(2),NDF,NDM,NEN1,NST,1)
      GO TO 1
C
C---- MACRO 'READ'
C---- READ THE MESH FOR A RESTART
400   CALL SAVE(TITL(2),NDF,NDM,NEN1,NST,2)
      GO TO 1
C---- INPUT/OUTPUT FORMATS
1000  FORMAT(20A4)
 1001 FORMAT(16I5)
2000  FORMAT(' F I N I T E   E L E M E N T   A N A L Y S I S   P R O G R
     1 A M')
2001  FORMAT(1H ,20A4//
     1 5X,30HNUMBER OF NODAL POINTS       =,I6/
     2 5X,30HNUMBER OF ELEMENTS           =,I6/
     3 5X,30HNUMBER OF MATERIAL SETS      =,I6/
     4 5X,30HDIMENSION OF COORDINATE SPACE=,I6/
     5 5X,30HDEGREES OF FREEDOM/NODE      =,I6/
     6 5X,30HNODES/ELEMENT (MAXIMUM)      =,I6/
     7 5X,30HDIMENSION OF STRESS ARRAY    =,I6/
     8 5X,30HDIMENSION OF INT VAR ARRAY   =,I6/
     9 5X,30HNUMBER OF QUAD PTS/ELEMENT   =,I6/
     1 5X,30HNUMBER OF PROP LD CARDS      =,I6/
     2 5X,30HNUMBER OF DISTR EDG LOADS    =,I6/
     3 5X,30HAUTO STEPPING CODE           =,I6/
     4 5X,30HNUMBER OF SLAVE NODES        =,I6)
2002  FORMAT(5X,'NUMBER OF SLAVE NODES EXCEEDS 50')
      END
      SUBROUTINE SETMEM(J)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL PRT
      COMMON /PLONG/ KMAX
      COMMON /PRINT/ PRT
      COMMON /PSIZE/ MAX
C     COMMON M(1)
      COMMON /MAINN/ M(25000000)
C
C---- MONITOR AVAILABLE MEMORY IN BLANK COMMON
C
      KMAX = J
      IF(PRT) WRITE(6,6000) KMAX,MAX
6000  FORMAT ('   MEMORY REQUEST =',I8,', CORE =',I8)
      IF(KMAX.LE.MAX) RETURN
      WRITE(6,2000) KMAX,MAX
      STOP
2000  FORMAT(5X,49H**ERROR 01** INSUFFICIENT STORAGE IN BLANK COMMON/
     1   17X,11HREQUIRED  =,I8/17X,11HAVAILABLE =,I8/)
      END
      SUBROUTINE PZERO(V,NN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- ZERO REAL ARRAY
C
      DIMENSION V(*)
      DO 100 N = 1,NN
100   V(N) = 0.D0
      RETURN
      END
C--------COMMENTED FOR PENAL CONT.
      SUBROUTINE PROFIL(JDIAG,ID,IX,NDF,NEN1,NAD,IOP,PRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- COMPUTE PROFILE OF GLOBAL ARRAYS
C
      LOGICAL PRT
      CHARACTER*8 HEAD
      CHARACTER*1 O
      COMMON /CHEAD/ O,HEAD(20)
      COMMON /CDATA/ NUMNP,NUMEL,NUMMAT,NEN,NEQ,IPR,
     1 NSDM,NQDM,NQUAD
      DIMENSION JDIAG(*),ID(NDF,*),IX(NEN1,*)
      DATA WNOD/4HNODE/,WDIA/4HDIAG/,WDOF/4H DOF/,WEQN/4H EQN/
      GO TO (1,2), IOP
C---- SET UP SYSTEM SIZE
1     NEQ = NUMNP*NDF
      RETURN
C---- COMPUTE COLUMN HEIGHTS
2     CONTINUE
      DO 500 N = 1,NUMEL
      DO 400 I = 1,NEN
      II = IX(I,N)
      IF(II.EQ.0) GO TO 400
      DO 300 K = 1,NDF
      KK = (II-1)*NDF + K
      DO 200 J = I,NEN
      JJ = IX(J,N)
      IF(JJ.EQ.0) GO TO 200
      DO 100 L = 1,NDF
      LL = (JJ-1)*NDF + L
      M = MAX0(KK,LL)
      JDIAG(M) = MAX0(JDIAG(M),IABS(KK-LL))
100   CONTINUE
200   CONTINUE
300   CONTINUE
400   CONTINUE
500   CONTINUE
C---- COMPUTE DIAGONAL POINTERS FOR PROFILE
      NAD = 1
      JDIAG(1) = 1
      IF(NEQ.EQ.1) RETURN
      DO 600 N = 2,NEQ
600   JDIAG(N) = JDIAG(N) + JDIAG(N-1) + 1
      NAD = JDIAG(NEQ)
      WRITE(6,2004) NAD
      RETURN
2000  FORMAT(10(4X,A4))
2001  FORMAT(10I8)
2002  FORMAT(5X,6(1X,A4,1X,A4))
2003  FORMAT((5X,6(1X,I3,1H=,I5)))
2004  FORMAT(//5X,'SIZE OF STIFFNESS MATRIX IN PROFILE FORM=',I8)
      END
      SUBROUTINE SAVE(TITL,NDF,NDM,NEN1,NST,ISW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*4 TITL
      CHARACTER*8 HEAD
      CHARACTER*1 O
      COMMON /CHEAD/ O,HEAD(20)
      COMMON /CDATA/ NODES(5),IPR,
     1 NSDM,NQDM,NQUAD
      COMMON /MDATA/ NN,N0,N1,N2,N3,N301,N302,N4,N5,N6,N7,N8,N9,N91,
     1 N10,N11,N12,N13,N14,N15,N16,N161,N162,N163,N164,N165,N166,
     1 N17,N18,N181,N182,N183,N184,N185,N186,N19,N20
      COMMON/PLONG/ KMAX
C     COMMON M(1)
      COMMON /MAINN/ M(25000000)
C---- READ AND WRITE MESH TO UNIT 2 ON A FILE CALLED 'TITL'
      GO TO (1,2), ISW
C---- WRITE THE MESH TO UNIT 2
1     OPEN(UNIT=2,FILE=TITL,STATUS='NEW',ACCESS='SEQUENTIAL',
     1 FORM='UNFORMATTED')
      WRITE(6,2000) TITL
      REWIND 2
      WRITE(2) O,HEAD,NODES,NN,NDF,NDM,NEN1,NST,KMAX,(M(I),I=1,KMAX)
      CLOSE(2)
      RETURN
C---- READ THE MESH FROM UNIT 2
2     OPEN(UNIT=2,FILE=TITL,STATUS='OLD',ACCESS='SEQUENTIAL',
     1 FORM='UNFORMATTED')
      WRITE(6,2001) TITL
      REWIND 2
      READ(2)  O,HEAD,NODES,NN,NDF,NDM,NEN1,NST,KMAX,(M(I),I=1,KMAX)
      CLOSE(2)
      RETURN
2000  FORMAT('MESH WRITTEN TO FILE NAMED ',A4)
2001  FORMAT('MESH READ FROM FILE NAMED ',A4)
      END
      SUBROUTINE ELMLIB(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,
     1 I,J,K,NS,NQ,ISW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- ELEMENT LIBRARY
C
      COMMON /ELDATA/ DM,N,MA,MCT,IEL,NEL
      DIMENSION P(K),S(K,K),D(*),U(*),X(*),IX(*),T(*)
      DIMENSION STR(NS,*),EPS(NS,*),Q(NQ,*)
      DIMENSION V(*),A(*)
      IF(IEL.LE.0.OR.IEL.GT.9) GO TO 400
      IF (ISW.NE.1) THEN
      DO 10 L = 1,K
   10 P(L) = 0.D0
      DO 20 L = 1,K
      DO 20 M = 1,K
20    S(L,M) = 0.D0
      END IF
      GO TO (1,2,3,4,5,6,7,8,9),IEL
1     CONTINUE
      CALL ELMT01(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
2     CONTINUE
      CALL ELMT02(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
3     CONTINUE
      CALL ELMT03(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
4     CONTINUE
      CALL ELMT04(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
5     CONTINUE
      CALL ELMT05(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
6     CONTINUE
      CALL ELMT06(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
7     CONTINUE
      CALL ELMT07(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
8     CONTINUE
      CALL ELMT08(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
      GO TO 100
9     CONTINUE
      CALL ELMT09(D,U,X,STR,EPS,Q,IX,T,S,P,V,A,I,J,K,NS,NQ,ISW)
100   RETURN
400   WRITE(6,4000) IEL
      STOP
4000  FORMAT(5X,39H**FATAL ERROR 04** ELEMENT CLASS NUMBER,I3,6H INPUT)
      END
      SUBROUTINE NORM(X,Y,N,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- NORMALIZE VECTOR Y TO UNIT VECTOR X
C
      LOGICAL FLAG
      DIMENSION X(*),Y(*)
      SCALE = DSQRT(DOT(Y,Y,N))
      IF(FLAG) SCALE = DSQRT(DOT(X,Y,N))
      DO 100 I = 1,N
100   X(I) = Y(I)/SCALE
      RETURN
      END
      SUBROUTINE PROMUL(A,B,C,JDIAG,NEQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(*),B(*),C(*),JDIAG(*)
C
C---- ROUTINE TO FORM C = C + A*B WHERE A IS A SYMMETRIC SQUARE MATRIX
C---- STORED IN PROFILE FORM, B,C ARE VECTORS, AND JDIAG LOCATES THE
C---- DIAGONALS IN A.
C
      JS = 1
      DO 200 J = 1,NEQ
      JD = JDIAG(J)
      IF(JS.GT.JD) GO TO 200
      BJ = B(J)
      AB = A(JD)*BJ
      IF(JS.EQ.JD) GO TO 150
      JB = J - JD
      JE = JD - 1
      DO 100 JJ = JS,JE
      AB = AB + A(JJ)*B(JJ+JB)
100   C(JJ+JB) = C(JJ+JB) + A(JJ)*BJ
150   C(J) = C(J) + AB
200   JS = JD + 1
      RETURN
      END
      DOUBLE PRECISION FUNCTION DOT(A,B,N)
C     REAL FUNCTION DOT(A,B,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C---- VECTOR DOT PRODUCT
C
      DIMENSION A(*),B(*)
      DOT = 0.D0
      DO 100 I = 1,N
100   DOT = DOT + A(I)*B(I)
      RETURN
      END
      LOGICAL FUNCTION PCOMP(A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PCOMP = .FALSE.
C---- IT MAY BE NECESSARY TO REPLACE THE FOLLOWING ALPHANUMERIC
C---- COMPARISON STATEMENT IF COMPUTER PRODUCES AN OVERFLOW
      IF(A.EQ.B) PCOMP = .TRUE.
      RETURN
      END
C     INTEGER FUNCTION WATCH(STRING,L)
C
C---- PRINT OUT CPU TIME (VAX-VMS)
C
C     CHARACTER*22 STRING
C
C     WRITE(6,'(2X,A23)') '**'//STRING(2:)
C     RETURN
C     END
