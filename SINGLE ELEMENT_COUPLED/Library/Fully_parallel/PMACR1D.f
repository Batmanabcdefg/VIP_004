      SUBROUTINE PMACR(UL,XL,TL,LD,P,PDIST,IDIST,S,IE,D,ID,X,IX,IDPROP
     1 ,F,T,JDIAG,STR,EPS,Q,B,DELFRC,UNEW,OLDFRC,VVECT,WVECT,TTABLE,
     2 PTABLE,DR,VELG,ACCELG,STROLD,EPSOLD,QOLD,BOLD,VELOLD,ACCOLD,
     3 VEL,ACCEL,CT,XRM,NDF,NDM,NEN1,NST,NSTR,NQ,NEND,NPLD,NDIST,PRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

!---- MACRO INSTRUCTION SUBPROGRAM
!---- MODIFIED BY R.NARASIMHAN ON JAN 22, 1987

!---- CONTROLS PROBLEM SOLUTION AND OUTPUT ALGORITHMS

!     EXTERNAL WATCH
!     INTEGER*4 CPUTIME
      INTEGER CPUTIME
      LOGICAL AFR,BFR,CFR,AFL,BFL,CFL,DFL,EFL,GFL,PCOMP,PFR,PRT,TFL,
     1 IFL,BLKFL,SRCLIN,UPDATE,STEDFL,FSTRFL,RNSTFL,HFL
      LOGICAL DUMPFL,MAFL01,MAFL02,MAFL03
      CHARACTER*8 HEAD
      CHARACTER*1 O
!     COMMON M(1)
      COMMON /MAINN/ M(25000000)
      COMMON /CHEAD/ O,HEAD(20)
      COMMON /CDATA/ NUMNP,NUMEL,NUMMAT,NEN,NEQ,IPR,
     1 NSDM,NQDM,NQUAD
      COMMON /PRINT/ PFR
      COMMON /PRLOD/ PROP(7),PROPOL(7)
!     COMMON /PTABLE/ NPLD,KPLD,T1,P1,T2,P2
      COMMON /SUBDT/ MD,MV,MF
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      COMMON /CEQS/ NCEQS
      COMMON /FAILPAR/ CRVVF
      COMMON /POINTR/ NE,NN,NA,NC,NV,NM,NA2,NA3
      COMMON /FLAGS/ AFR,BFR,CFR,AFL,BFL,CFL,DFL,EFL,GFL,TFL,IFL,BLKFL
     1 ,SRCLIN,HFL
      COMMON /ITCOUN/ NITER
      COMMON /CONVER/ TOL
      COMMON /CNVG1/ ICONV,IDIVG,IPATH
      COMMON /CPU/ CPUTIME
      COMMON /AUTSTP/ IAUTO
      COMMON /TAPE/ NMAT,NRED,NPVT,NELSTF,NBFGS,LDUMP,LREST,LSEFF,
     1 LDISP,LPRTS,LRESF,LSMTH
      COMMON /PRTSET/ NSET(9,201)
      COMMON /BLOCK/ MAXAV,LBLOK,NBLOK,MAXC,NELCOR
      COMMON /STEADY/ NELROW,IELROW,NELOUT
      COMMON /FSTRN/ ALPHA1,NSBSTP
      COMMON /TMPRIS/ XTMPR,YTMPR,CTMPR,ITMFLG,IELTMP,NELTMP,TEMPRS
      COMMON /WEDGE/ NSURF,ISURF(50),CPSURF(2,50),NDSURF(50),
     1 THTSRF,PENSRF
      COMMON /COHES/ NINTND, INTND(2,100),ALPAA,DLTAA,SIGMXX,
     1 XLNTND(100),ANGINT(100),CPINT(2,100),XLN(100),ISTAT(100)
!     COMMON /CNTAC/ CP(2,50),BET(50),DEL(2,50),ISLAV(50),
!    1 IMAST(100),IAB(2,50),MSEG(50),NDEST(50),ANG(50),DUSL(2,50),
!    1 SMU,DMU,NSLAV,NMAST,ALP,FRTOL
      COMMON /STRLOC/ XANGPT,YANGPT,IELPT,STRSPT
      COMMON /JAUX/ IAUX,STRAUX(4),EPSAUX(2),XCT(2),RAD,MODE
      common /cnvnorm/ rn,enrg
      DIMENSION WD(51),CT(4,*),LVS(9),LVE(9),JDIAG(*),
     1   UL(*),XL(*),TL(*),LD(*),P(*),S(*),IE(*),D(*),ID(*),X(*),
     2   IX(*),F(*),T(*),B(*),DR(*)
      DIMENSION DELFRC(*),UNEW(*),IDPROP(*),TTABLE(*),PTABLE(7,*)
      DIMENSION OLDFRC(*),VVECT(NEQ),WVECT(NEQ)
!     DIMENSION PROP(7),PROPOL(7),PRSAVE(7),DPROP(7)
      DIMENSION PRSAVE(7),DPROP(7)
      DIMENSION PDIST(NST,*),IDIST(2,*)
      DIMENSION STR(NSTR,*),EPS(NSTR,*),Q(NQ,*)
      DIMENSION STROLD(NSTR,*),EPSOLD(NSTR,*),QOLD(NQ,*)
      DIMENSION VELG(*),ACCELG(*),VEL(*),ACCEL(*)
      DIMENSION BOLD(*),VELOLD(*),ACCOLD(*)
      DIMENSION SIG(6),SEFFEC(9),VARX(3)
!     DIMENSION XRM(1)
      DIMENSION XRM(*)
!     EQUIVALENCE (M(1),XRM(1))
      DATA WD/4HTOL ,4HDT  ,4HSTRE,4HDISP,4HTANG,4HFORM,4HLOOP,4HNEXT,
     1        4HPROP,4HCEQS,4HTIME,4HCONV,4HSOLV,4HLMAS,4HCMAS,4HMESH,
     2        4HEIGE,4HPLOT,4HUTAN,4HREAC,4HCHEC,4HPRIN,4HNOPR,4HRATE,
     3        4HRESE,4HEMAX,4HSUBS,4HHIST,4HRESF,4HPRED,4HPARA,4HEXCH,
     4        4HEXCD,4HCORR,4HCPU ,4HREST,4HACCE,4HMA01,4HMA02,4HMA03,
     5        4HLSRC,4HBFGS,4HJINT,4HDDIS,4HSEFF,4HPRTS,4HSTED,4HFSTR,
     6        4HRNST,4HSMTH,4HRITZ/
      DATA NWD/51/,ENDM/4HEND /,NC/1/,IDVGLM/3/
!     DATA LDUMP/9/,LREST/19/,IDVGLM/3/
!-------------------------------------------------------------------------------------------------
!	integer omp_get_num_threads,omp_get_thread_num 
!-------------------------------------------------------------------------------------------------

!---- SET INITIAL VALUES OF PARAMETERS
      PRT = .TRUE.
      NV = 1
!     DT = 0.0E0
      DT = 0.0D0
      DO 109 I=1,7
      PROP(I) = 1.0D0
109   PROPOL(I) = 1.0D0
      RNMAX = 0.0D0
      ENRGLM=0.0D0
      NITER = 0
      RMMAX = 0.0D0
      RM = 0.0D0
      RN = 0.0D0
      RN1 = 0.0D0
      TIME = 0.0D0
      TIMSTP=1.D0
      TOL = 1.D-9
      ENRTOL=1.D-9
      STOL=0.5
      STEP=1.D0
      GSTEP0=0.D0
      GSTEP=0.D0
      DRNORM=1.D0
      CNDMAX=1.0D+05
      SHFTEG = 0.D0
      DDNRM = 0.D0
      IPATH=0
      ICONV=1
      NATMPT=1
      NCONV=0
      UN = 0.0D0
      NELROW = 0
      NELOUT = 0
      DSPNRM = 0.D0
      ALPHA1 = 0.2
      NSBSTP = 1
      MAFL01 = .TRUE.
      MAFL02 = .TRUE.
      MAFL03 = .TRUE.
      IFL = .TRUE.
      TFL = .FALSE.
      AFL = .TRUE.
      AFR = .FALSE.
      BFL = .TRUE.
      BFR = .FALSE.
      CFL = .TRUE.
      CFR = .FALSE.
      DFL = .TRUE.
      EFL = .TRUE.
      GFL = .TRUE.
      HFL = .TRUE.
      PFR = .TRUE.
      BLKFL=.FALSE.
      SRCLIN=.FALSE.
      STEDFL = .FALSE.
      FSTRFL = .FALSE.
      RNSTFL = .FALSE.
      NE = NEND
!     NPLD=0
!     NEQT = NEQ + NSLAV*NDF
      WRITE(6,2001) O,HEAD
!---- SET UP INITIAL CONDITIONS (FROM INPUT-MACRO INIT)
!---- THE FOLL 2 CARDS WERE COMMENTED OUT ON OCT 24,1988
!---- SINCE THE PRESENT VERSION OF PMESH DIRECTLY READS INITIAL
!---- DISPLACEMENTS INTO ARRAY 'B' USING MACRO 'INIT'
!     DO 105 I = 1,NEQ
! 105 B(I) = DR(I)
      DO 105 I =1,NEQ
105   OLDFRC(I) = 0.D0
!105   OLDFRC(I) = 0.D0
!---- READ MACRO CARDS
      LL = 1
      LMAX = 16
      CALL SETMEM(NE+LMAX*4*IPR)
      CT(1,1) = WD(7)
      CT(3,1) = 1.D0
100   LL = LL + 1
      IF(LL.LT.LMAX) GO TO 110
      LMAX = LMAX + 16
      CALL SETMEM(NE+LMAX*4*IPR)
110   CONTINUE
      READ(5,1000)  (CT(J,LL),J=1,4)
      WRITE(6,2000) (CT(J,LL),J=1,4)
      IF(.NOT.PCOMP(CT(1,LL),ENDM)) GO TO 100
200   CT(1,LL)= WD(8)
!---- SET LOOP MARKERS
      NE = NE + LMAX*4*IPR
      LX = LL - 1
      DO 230 L = 1,LX
      IF(.NOT.PCOMP(CT(1,L),WD(7))) GO TO 230
      J = 1
      K = L + 1
      DO 210 I = K,LL
      IF(PCOMP(CT(1,I),WD(7))) J = J + 1
      IF(J.GT.9) GO TO 401
      IF(PCOMP(CT(1,I),WD(8))) J = J - 1
210   IF(J.EQ.0) GO TO 220
      GO TO 400
220   CT(4,I) = L
      CT(4,L) = I
230   CONTINUE
      J = 0
      DO 240 L = 1,LL
      IF(PCOMP(CT(1,L),WD(7))) J = J + 1
240   IF(PCOMP(CT(1,L),WD(8))) J = J - 1
      IF(J.NE.0) GO TO 400
!---- EXECUTE MACRO INSTRUCTION PROGRAM
      LV = 0
      L = 1
299   DO 300 J = 1,NWD
300   IF(PCOMP(CT(1,L),WD(J))) GO TO 310
      GO TO 330
310   I = L - 1
      IF((L.NE.1.AND.L.NE.LL).AND.PFR)
     1WRITE(6,2010) I,(CT(K,L),K = 1,4)
      GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
     1  23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,41,42,1322,43,
     2 44,45,46,47,48,49,51,52,53),J

!---- MACRO 'TOL '
!---- SET SOLUTION TOLERANCE
1     TOL = CT(3,L)
      IF(CT(4,L).GT.0.D0) ENRTOL=CT(4,L)
      GO TO 330

!---- MACRO 'DT  '
!---- SET TIME INCREMENT
2     DT = CT(3,L)
      GO TO 330

!---- MACRO 'STRE'
!---- PRINT STRESS VALUES
3     LX = LVE(LV)
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.0D0)).EQ.0.0D0)
      EMOD2=DMAX1(CT(3,L),1.0D0)
      IF(DMOD(CT(3,LX),EMOD2).EQ.0.0D0)
     1   CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,
     2   JDIAG,STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     3   NDF,NDM,NEN1,NST,NSTR,NQ,4,B,
!    4   M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
     4   DR,.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      GO TO 330

!---- MACRO 'DISP'
!---- PRINT NODAL ARRAYS
4     LX = LVE(LV)
      XKEY0 =4H    
      XKEY1 =4HDISP
      XKEY2 =4HVELO
      XKEY3 =4HACCE
      XKEY4 =4HEIGV
!---- PRINT DISPLACEMENTS
      IF ((CT(2,L).EQ.XKEY0).OR.(CT(2,L).EQ.XKEY1)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.0D0)).NE.0.0D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.0D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.0D0) GO TO 330
      CALL PRTDIS(ID,X,B,IDPROP,PROP,F,NDM,NDF)
      GO TO 330
      END IF
!---- PRINT VELOCITIES
      IF (CT(2,L).EQ.XKEY2) THEN
      CALL PRTNOD(VELG,'VELOCITIES    ',NDF)
      GO TO 330
      END IF
!---- PRINT ACCELERATIONS
      IF (CT(2,L).EQ.XKEY3) THEN
      CALL PRTNOD(ACCELG,'ACCELERATIONS ',NDF)
      GO TO 330
      END IF
!---- PRINT EIGENVECTORS
      IF (CT(2,L).EQ.XKEY4) THEN
      N1 = CT(3,L)
      N2 = CT(4,L)
      N1 = MAX0(1,MIN0(NF,N1))
      IF(N2.EQ.0) N2 = NF
      N2 = MAX0(N2,N1)
      KK = 0
      CALL PZERO(DR,NEQ)
      DO 412 NNN=N1,N2
      CALL PRTDIS(ID,X,M(MV+KK),IDPROP,PROP,DR,NDM,NDF)
      KK = KK + NEQ*IPR
412   CONTINUE
      GO TO 330
      END IF

!---- MACRO 'UTAN'
!---- FORM UNSYMMETRIC TANGENT STIFFNESS
19    CONTINUE
      LX=LVE(LV)
      IF(CT(3,LX).NE.1.D0) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.D0) GO TO 330
      END IF
      IF(CFL) CALL PSETM(NC,NE,JDIAG(NEQ)*IPR,CFL)
      RM = 0.0D0
      CALL PZERO(M(NC),JDIAG(NEQ))
      CFR = .TRUE.

!---- MACRO 'TANG'
!---- FORM SYMMETRIC TANGENT STIFFNESS
5     CONTINUE
      LX=LVE(LV)
      IF(CT(3,LX).NE.1.D0) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.D0) GO TO 330
      END IF
      IF(PFR) WRITE(6,2022)
      IF(J.EQ.5) CFR = .FALSE.
      XKEY0=4H    
      XKEY1=4HBLOK
      XKEY2=4HFORC
      XKEY3=4HNEWM
      IF(CT(2,L).NE.XKEY1) THEN
      IF(GFL) CALL PSETM(NA,NE,JDIAG(NEQ)*IPR,GFL)
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      CALL PZERO(M(NA),JDIAG(NEQ))
      BFR = .FALSE.
      IF(CT(2,L).EQ.XKEY2) BFR=.TRUE.
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     2 STR,EPS,Q,DR,M(NA),M(NC),
     3 VELG,ACCELG,VEL,ACCEL,NDF,NDM,
     4 NEN1,NST,NSTR,NQ,3,B,M(NV),.TRUE.,BFR,CFR,
     5 .FALSE.)
      AFR = .TRUE.
      IF(CT(2,L).EQ.XKEY3) BFR = .TRUE.
!     IF(NSLAV.GT.0)
!    1 CALL CNTCTR(M(NA),DR,M(NC),JDIAG,X,B,IDPROP,PROP,F,ID,AFR,
!    1 BFR,CFR,NDF,1)
!     IF(NSURF .GT.0)THEN
!      CALL ASSPSURF(M(NA),DR,JDIAG,F,ID,IDPROP,PROP,B,X,NDF,
!    1 .TRUE.,.TRUE.)
!     ENDIF
!     IF(NINTND.GT.0) 
!    1 CALL ASSPINT(M(NA),DR,M(NC),JDIAG,B,X,NDF,NDM,AFR,BFR,
!    2 CFR,ID)
      IF(CT(2,L).EQ.XKEY2) THEN
      DO 551 N=1,NEQ
      OLDFRC(N)=DR(N)
 551  CONTINUE
      ENDIF
!---- MODIFY STIFF MATRICES IN CASE RING-BY-RING STATIC CONDENSATION IS DONE.
      IF(RNSTFL)
     1 CALL HADD(M(NA),M(NC),M(NMRC1),JDIAG,N2GAMA,N4GAMA,NEQ,AFR,CFR)         

      IF(CT(2,L).EQ.XKEY3) THEN
!----- MODIFY STIFF MX FOR MASS TERMS WHILE DOING NEWMARK TIME INTEGRN
      IF(EFL) WRITE (6,2042)
      IF(.NOT.TFL) WRITE(6,2043)
      CALL NEWMST(M(NA),M(NN),ID,DR,ACCELG,JDIAG,NEQ)
      END IF
      GO TO 330
      END IF
      BLKFL=.TRUE.
      IF(GFL) THEN
      CALL BLKCMP(JDIAG,NA,NE,NEQ,NST,IPR)
      NA2=NA+LBLOK*IPR
      NA3=NA2+LBLOK*IPR
      CALL BLKCOL(JDIAG,M(NA3),NEQ,NST)
      END IF
      GFL=.FALSE.
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      CALL PZERO(M(NA),LBLOK)
      CALL PZERO(M(NA2),LBLOK)
      CALL PFORM1(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     2 STR,EPS,Q,DR,M(NA),M(NA2),M(NA3),
     3 VELG,ACCELG,VEL,ACCEL,AVDIAG,NDF,NDM,
     4 NEN1,NST,NSTR,NQ,3,B,M(NV),.TRUE.,.FALSE.,.FALSE.,
     5 .FALSE.)
      AFR=.TRUE.
      GO TO 330

!---- MACRO 'FORM'
!---- FORM OUT OF BALANCE FORCE FOR TIME STEP/ITERATION
6     CONTINUE
      XKEY0 =4H    
      XKEY1 =4HCHEC
      XKEY2 =4HNOCH
      XKEY3 =4HPRIN

      IF(STEDFL) THEN
      DO 66 N = 1,NEQ
      OLDFRC(N) = B(N)
66    B(N) = 0.D0
      END IF

      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      call pzero(dr,neq)
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      IF(.NOT.BLKFL) THEN
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
!---- MODIFY FORCE VECTOR TO ACCOUNT FOR ADDED STIFFNESS ON OUTERMOST RING
!---- IN CASE RING-BY-RING STATIC CONDENSATION IS DONE
      IF(RNSTFL)
     1 CALL FADD(M(NMRC1),M(NMRC2),PROP,DR,B,N2GAMA,N4GAMA,NEQ)
      END IF
      IF(BLKFL) THEN
      CALL PFORM1(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,M(NA),M(NA2),M(NA3),VELG,ACCELG,VEL,ACCEL,
     2   AVDIAG,NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
      END IF
      BFR = .TRUE.
      IF(STEDFL) GO TO 330
      IF (CT(2,L).EQ.XKEY1) THEN
      RN = 0.0D0
      DO 61 N = 1,NEQ
61    RN = RN + DR(N)**2
!     RN = SQRT(RN)
      RN = DSQRT(RN)
!     RNMAX = DMAX1(RNMAX,RN)
!     RNMAX = AMAX1(RNMAX,RN)
      NITER = NITER + 1
      IF(NITER.EQ.1) RNMAX=RN
      IF(PFR) WRITE(6,2005) RNMAX,RN,TOL
      IF(RN.GT.RNMAX*TOL) GO TO 330
65    NITER = NITER - 1
      WRITE(6,'(2X,''**ITERATIONS TO CONVERGENCE = '',I5)') NITER
      NITER = 0
      ICONV=1
      LX = LVE(LV)
      L0 = LVS(LV)
      CT(3,LX) = CT(3,L0)
      L = LX - 1
      END IF
      IF(CT(2,L).EQ.XKEY3) THEN
!     IF(NSLAV.GT.0)
!    1 CALL CNTCTR(M(NA),DR,M(NC),JDIAG,X,B,IDPROP,PROP,F,ID,.TRUE.,
!    1  .TRUE.,CFR,NDF,1)
!     IF(NSURF .GT. 0)
!    1 CALL ASSPSURF(M(NA),DR,JDIAG,F,ID,IDPROP,PROP,B,X,NDF,
!    2 .FALSE.,.TRUE.)
!     IF(NINTND.GT.0) 
!    1 CALL ASSPINT(M(NA),DR,M(NC),JDIAG,B,X,NDF,NDM,.FALSE.,.TRUE.,
!    2 .FALSE.,ID)
      RN1 = 0.D0
      DO 63 I=1,NEQ
      IF(ID(I).EQ.0) THEN
      RN1 = RN1 + DR(I)*DR(I)
      END IF
63    CONTINUE
!     RN1 = SQRT(RN1)
      RN1 = DSQRT(RN1)
      WRITE(6,'(5X,''INITIAL FORCE NORM ='',E13.5, 3X,
     1 ''FINAL FORCE NORM ='',E13.5)') RN, RN1
      END IF
      DO 62 N=1,NEQ
62    OLDFRC(N)=DR(N)
      GO TO 330

!---- MACRO 'LOOP'
!---- SET LOOP START INDICATORS
7     LV = LV + 1
      LX = CT(4,L)
      LVS(LV) = L
      LVE(LV) = LX
      CT(3,LX) = 1.
      XKEY0=4H    
      XKEY1=4HITRN
      IF(CT(2,L).EQ.XKEY1) THEN
!---- THIS IS A NEWTON ITERATION LOOP:
      WRITE(6,2021) TIMSTP,NATMPT,DT,TIME
      NITER=0
      ICONV=0
      IDIVG=0
      NUMUPD=0

!     IF(FSTRFL) THEN
!---- FINITE STRAIN PLASTICITY WITH RATE CONSTITUTIVE EQUATION (STATIC ANALYSIS)
      DO 717 I=1,NEQ
      DELFRC(I) = 0.d0
      UNEW(I) = ACCELG(I)
      WVECT(I) = VELG(I)
717   CONTINUE
!     END IF

      IF(CT(3,L).LE.1) ICONV=1
      IF(IAUTO.EQ.1) THEN
!---- AUTO STEPPING HAS BEEN REQUESTED
      IF(NATMPT.EQ.1) THEN
!---- FIRST ATTEMPT OF TIME STEP: SAVE STRESSES,STRAINS, DISPLACEMENTS,
!---- VELOCITIES AND ACCELERATIONS OF LAST CONVERGED TIME STEP.
      DO 711 I=1,NEQ
      BOLD(I)=B(I)
      VELOLD(I)=VELG(I)
      ACCOLD(I)=ACCELG(I)
711   CONTINUE
      DO 712 J=1,NUMEL
      DO 712 I=1,NSTR
      STROLD(I,J)=STR(I,J)
      EPSOLD(I,J)=EPS(I,J)
712   CONTINUE
      DO 713 J=1,NUMEL
      DO 713 I=1,NQ
      QOLD(I,J)=Q(I,J)
713   CONTINUE
      END IF
      IF(NATMPT.GT.1) THEN
!---- SUBSEQUENT ATTEMPTS IN AUTO STEPPING: RECOVER STRESSES,STRAINS,
!---- DISPLACEMENTS,VELOCITIES,ACCELERATIONS OF LAST CONVERGED TIME STEP.
      DO 714 I=1,NEQ
      B(I)=BOLD(I)
      VELG(I)=VELOLD(I)
      ACCELG(I)=ACCOLD(I)
714   CONTINUE
      DO 715 J=1,NUMEL
      DO 715 I=1,NSTR
      STR(I,J)=STROLD(I,J)
      EPS(I,J)=EPSOLD(I,J)
715   CONTINUE
      DO 716 J=1,NUMEL
      DO 716 I=1,NQ
      Q(I,J)=QOLD(I,J)
716   CONTINUE
      END IF
      END IF
      END IF
      GO TO 330

!---- MACRO 'NEXT'
!---- LOOP TERMINATOR CONTROL
8     N = CT(4,L)
      XKEY0=4H    
      XKEY1=4HITRN
      CT(3,L) = CT(3,L) + 1.D0
!---- FOR AN ITERATION LOOP: CHECK WHETHER CONVERGENCE HAS BEEN ATTAINED
!----                        IF SO EXIT ITERATION LOOP.
!----                        OTHERWISE CHECK IF MAX # OF ITERNS SPECIFIED
!----                        HAVE BEEN PERFORMED.
!----                        IF SO TERMINATE THE PROGRAM WITH ERROR STATUS
      IF(CT(2,N).EQ.XKEY1) THEN
      NUMUPD=0
      IF(ICONV.EQ.1) CT(3,L)=CT(3,N)+1
      IF((ICONV.NE.1).AND.(CT(3,L).GT.CT(3,N))) GO TO 406
      END IF
      IF(CT(3,L).GT.CT(3,N)) LV = LV - 1
      IF(CT(3,L).LE.CT(3,N)) L = N
      GO TO 330

!---- MACRO 'PROP'
!---- INITIALIZE PROPORTIONAL LOAD TABLE
9     CONTINUE

!     NPLD = CT(3,L)
!     READ (5,'(2F10.0)') T1,P1
!     READ (5,'(2F10.0)') T2,P2
!     KPLD = 2
!     PROP = PROPLD(TIME)

      IF(NPLD.LE.0) THEN
      WRITE(6,2030) NPLD
      STOP
      END IF
      DO 91 I=1,NPLD
      READ(5,'(8F10.0)') TTABLE(I), (PTABLE(J,I),J=1,7)
91    CONTINUE
      CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      GO TO 330

!---- MACRO 'CEQS'
!---- INTEGRATE CONSTITUTIVE EQUATIONS (ENTERS ELEMENT SUBROUTINE
!---- WITH ISW = 9)
   10 CONTINUE
      XKEY0 =4H    
      XKEY1 =4HINCR
      NCEQS = CT(3,L)
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      IF (CT(2,L).EQ.XKEY0) THEN
!      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
!     1 NST,NDIST)
!------------------------------------------------------------------------
!     DO 9912 I = 1,NEQ
!     IND = IDPROP(I)
!     DR(I) = PROP(IND)*F(I) - B(I)
!     B(I) = PROP(IND)*F(I)
!9912  CONTINUE
!------------------------------------------------------------------------
      if(nceqs.eq.1) then
      do 101 i=1,neq
      delfrc(i) = delfrc(i) + dr(i)
      dr(i) = delfrc(i)
101   continue
      end if
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,B,
     3 M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      END IF
      IF (CT(2,L).EQ.XKEY1) THEN
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,B,B,B,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,DR,
     3 M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      END IF
!---- CHECK IF THERE IS PLASTIC DISSIPATION OR IF THE PLASTIC
!---- STRAIN INCREMENT IS TOO LARGE
      IF(IDIVG.EQ.999) GO TO 416
      GO TO 330

!---- MACRO 'TIME'
!---- INCREMENT TIME
11    CONTINUE
      TIMOLD=TIME
      LX=LVE(LV)
      TIMSTP=CT(3,LX)
      TIME = TIME + DT
      TMAX = CT(3,L)
      TMAX1=0.9999*TMAX
      IF (TMAX.GT.0.D0) THEN
      IF (TIME.GE.TMAX1) THEN
!     WRITE(6,2008)
!     STOP

      TIME=TMAX
      L0=LVS(LV)
      LX=LVE(LV)
      CT(3,LX)=CT(3,L0)

      END IF
      END IF
      RNMAX = 0.0D0
      RMMAX = 0.0D0
      NITER = 0
      UN = 0.D0
!     PROPOL = PROP

      NATMPT=1
      DO 112 I=1,7
112   PROPOL(I)=PROP(I)

      GO TO 330

!---- MACRO 'CONV'
!---- INTERNAL ENERGY AND OUT-OF-BALANCE FORCE CONVERGENCE TEST
12    CONTINUE
      XKEY1=4H    
      XKEY2=4HAUTO

      IF(STEDFL) THEN
      NITER = NITER+1
      DNRM = 0.D0
      DDNRM = 0.D0
      DO 120 N=1,NEQ
      DNRM = DNRM + B(N)*B(N)
      IF(NITER.GT.1) THEN
      DDNRM = DDNRM + (B(N) - OLDFRC(N))*(B(N) - OLDFRC(N))
      END IF
120   CONTINUE
!     DNRM = SQRT(DNRM)
      DNRM = DSQRT(DNRM)
!     DDNRM = SQRT(DDNRM)
      DDNRM = DSQRT(DDNRM)
      IF(PFR) WRITE(6,'(2X,'' DISPLACEMENT NORM = '',E15.7,
     1 2X,'' INCR DISPLC NORM = '',E15.7)') DNRM,DDNRM
      IF(NITER.EQ.1) THEN
      DSPNRM = DNRM
      GO TO 330
      END IF
!     DNRM1 = ABS(DNRM-DSPNRM)
      DNRM1 = DABS(DNRM-DSPNRM)
      DNRM2 = TOL*DSPNRM
!     IF(DNRM1.GT.DNRM2) THEN
!     IF(DDNRM.GT.DNRM2) THEN
      IF((DNRM1.GT.DNRM2).OR.(DDNRM.GT.DNRM2)) THEN
      DSPNRM = DNRM
      GO TO 330
      END IF
      WRITE(6,'('' ITERATIONS TO CONVERGENCE = '',I5)') NITER
      NITER = 0
      LX = LVE(LV)
      L0 = LVS(LV)
      CT(3,LX) = CT(3,L0)
      L = LX-1
      GO TO 330
      END IF

      IF(CT(2,L).EQ.XKEY2) THEN
      DTMIN=CT(3,L)
      DTMAX=CT(4,L)
      END IF

!     RN=0.0
!     ENRG=0.0
!     DO 120 N=1,NEQ
!120   RN=RN+DELFRC(N)*DELFRC(N)
!     RN=DSQRT(RN)
!     ENRG=DOT(DELFRC,DR,NEQ)

      NITER=NITER+1
      IF(NITER.EQ.1) THEN
      RNMAX=RN
      ENRGLM=ENRG
      IF(PFR) WRITE(6,2012) RNMAX,ENRGLM
      GO TO 330
      END IF
      IF(PFR) WRITE(6,2014) RN,ENRG
!---- CHECK FOR DIVERGENCE IN NEWTON ITERATION
      IF(ENRG.GT.ENRGLM) THEN
      IDIVG=IDIVG+1
      IF(IDIVG.GT.IDVGLM) THEN
!---- DIVERGENCE IS DETECTED: IF AUTO STEPPING HAS BEEN REQUESTED CUT TIME
!----                         INCREMENT SIZE BY ONE FOURTH AND TRY AGAIN.
!----                       : OTHERWISE TERMINATE PROGRAM WITH ERROR STATUS.
      NCONV=0
      IF(CT(2,L).EQ.XKEY2) GO TO 407
      GO TO 405
      END IF
      GO TO 330
      END IF
      IDIVG=0
      IF((RN.GT.RNMAX*TOL).OR.(ENRG.GT.ENRGLM*ENRTOL)) GO TO 330
!---- CONVERGENCE HAS BEEN ATTAINED. RESET PARAMETERS
      ICONV=1
      WRITE(6,'('' ITERATIONS TO CONVERGENCE = '',I5)') NITER
      NCONV=NCONV+1
      NATMPT=1
      ENRGLM=0.D0
      RNMAX = 0.D0
      NITER = 0
      LX = LVE(LV)
      L0 = LVS(LV)
      CT(3,LX) = CT(3,L0)
      LOLD=L
      L = LX - 1
!---- CHECK IF CONVERGENCE TREND IS HEALTHY: IF SO, AND IF AUTO STEPPING
!----                                        HAS BEEN REQUESTED, INCREASE
!----                                        TIME INCREMENT SIZE BY 1.5.
      IF((NCONV.GT.2).AND.(CT(2,LOLD).EQ.XKEY2)) GO TO 410
      GO TO 330

!---- MACRO 'SOLV'
!---- SOLVE EQUATIONS
13    CONTINUE
      IF(.NOT.STEDFL) THEN
      DO 1301 I=1,NEQ
      OLDFRC(I) = DR(I)
1301  CONTINUE
      END IF
      IF(.NOT.BLKFL) THEN
      IF(CFR) GO TO 131
      CALL ACTCOL(M(NA),DR,JDIAG,NEQ,AFR,BFR)
      GO TO 132
131   CALL UACTCL(M(NA),M(NC),DR,JDIAG,NEQ,
     1 AFR,BFR)
132   AFR = .FALSE.
      END IF
      IF (BLKFL) THEN
      CALL PZERO(M(NA),LBLOK)
      CALL PZERO(M(NA2),LBLOK)
      IF(AFR)
     1 CALL OPTBLOK(M(NA),M(NA2),M(NA2),M(NA3),AVDIAG,NEQ,1)
      AFR = .FALSE.
      CALL PZERO(M(NA),LBLOK)
      CALL PZERO(M(NA2),LBLOK)
      IF(BFR) THEN
      CALL PSWITCH(M(NA),DR,NEQ)
      CALL OPTBLOK(M(NA),M(NA2),M(NA2),M(NA3),AVDIAG,NEQ,2)
      CALL PSWITCH(DR,M(NA),NEQ)
      END IF
      END IF
      IF(.NOT.BFR) GO TO 330
      BFR = .FALSE.
      XKEY0=4H    
      XKEY1=4HLSRC
      IF(CT(2,L).NE.XKEY1) THEN
      RN=0.D0
      ENRG=0.D0
      DO 1321 I=1,NEQ
      IF(ID(I).EQ.0) THEN
      RN=RN+OLDFRC(I)*OLDFRC(I)
      END IF
1321  CONTINUE
      RN=DSQRT(RN)
!     RN=SQRT(RN)
      ENRG=DOT(OLDFRC,DR,NEQ)
      STEP=1.D0
!     IF(NINTND.GT.0)
!    1 CALL FORCINT(DR,X,B,NDF,NDM)
      DO 1323 I=1,NEQ
1323  B(I)=B(I)+DR(I)

!     IF(NSLAV.NE.0)
!    1 CALL CONTFORC(DR,X,B,ID,NDF)
!     IF(NSURF .NE. 0)
!    1 CALL SURFFORC(DR,X,B,NDF)

!     IF(FSTRFL) THEN
!---- FINITE STRAIN PLASTICITY WITH RATE CONSTITUTIVE EQUATION (STATIC ANALYSIS)
!     IF(IPATH.EQ.0) THEN
!     DO 1324 I=1,NEQ
!     VELG(I) = VELG(I) + DR(I)
!1324  CONTINUE
!     END IF
!     IF(IPATH.EQ.1) THEN
!     DO 1325 I=1,NEQ
!     VELG(I) = DR(I)
!1325  CONTINUE
!     END IF
!     END IF

      GO TO 330
      END IF

!---------------------------------------------------------------------
!---- THE FOLLOWING SEGMENT WAS ADDED BY R.NARASIMHAN ON FEB 16, 1987
!---- TO PERFORM LINE SEARCH.
!---- ADAPTED FROM H.MATHIES AND G.STRANG, INT.J.NUM.METH.ENGG.,1979,P.1613

1322  CONTINUE
      RN=0.D0
      ENRG=0.D0
      DO 134 N=1,NEQ
134   RN=RN+OLDFRC(N)*OLDFRC(N)
      RN=DSQRT(RN)
!     RN=SQRT(RN)
      ENRG=DOT(OLDFRC,DR,NEQ)
      STEP=1.D0
!---- MAKE LINE SEARCH IN THE DIRECTION OF VECTOR DR (IF NECESSARY)
!---- AND DETERMINE STEP LENGTH.
      IF(CT(3,L).GT.0.D0) STOL=CT(3,L)
      SRCLIN=.TRUE.
      GSTEP0=ENRG
      GTOL=STOL*DABS(GSTEP0)
!     GTOL=STOL*ABS(GSTEP0)
      DO 135 I=1,NEQ
135   UNEW(I)=B(I)+DR(I)
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
!---- INTEGRATE CONSTITUTIVE LAW
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,UNEW,M(NV),.FALSE.,.FALSE.,.FALSE.,
     3 .FALSE.)
      IF(IDIVG.EQ.999) GO TO 416
!---- FORM RIGHT HAND SIDE VECTOR DELFRC
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DELFRC,NEQ,IDPROP,PROP,NEN,NEN1,
     1 NDF,NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,6,UNEW,M(NV),.FALSE.,.TRUE.,.FALSE.,
     3 .FALSE.)
      GSTEP=DOT(DELFRC,DR,NEQ)
      IF(DABS(GSTEP).LE.GTOL) THEN
!     IF(ABS(GSTEP).LE.GTOL) THEN
      WRITE(6,2029) STEP,GSTEP,GTOL
      GO TO 136
      END IF
      LINMAX=10
      SMAX=16.D0
      STEPB=0.D0
      STEPA=1.D0
      GSTEPB=GSTEP0
      GSTEPA=GSTEP
!---- FIND BRACKET [STEPB,STEPA] ON ZERO.
      GAGB=GSTEPA*GSTEPB
      IF(GAGB.LE.0.D0) GO TO 137
138   CONTINUE
      STEPA2=2.D0*STEPA
      IF(STEPA2.GE.SMAX) GO TO 137
      STEPB=STEPA
      STEPA=STEPA2
      GSTEPB=GSTEPA
      DO 1382 I=1,NEQ
1382  UNEW(I)=B(I)+STEPA*DR(I)
!---- INTEGRATE CONSTITUTIVE LAW
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,UNEW,M(NV),.FALSE.,.FALSE.,.FALSE.,
     3 .FALSE.)
      IF(IDIVG.EQ.999) GO TO 416
!---- FORM RIGHT HAND SIDE VECTOR DELFRC
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DELFRC,NEQ,IDPROP,PROP,NEN,NEN1,
     1 NDF,NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,6,UNEW,M(NV),.FALSE.,.TRUE.,.FALSE.,
     3 .FALSE.)
      GSTEPA=DOT(DELFRC,DR,NEQ)
      GAGB=GSTEPA*GSTEPB
      IF(GAGB.GT.0.D0) GO TO 138
137   CONTINUE
      STEP=STEPA
      GSTEP=GSTEPA
      IF(GAGB.GT.0.D0) THEN
      WRITE(6,2027) STEP,GSTEP
      GO TO 136
      END IF
      IF(GAGB.EQ.0.D0) THEN
      LIN=0
      WRITE(6,2028) STEP,GSTEP,GTOL,LIN
      GO TO 136
      END IF
!---- ILLINOIS ALGORITHM TO FIND ZERO:
      LIN=0
      IF(DABS(GSTEP).LE.GTOL) THEN
!     IF(ABS(GSTEP).LE.GTOL) THEN
      WRITE(6,2028) STEP,GSTEP,GTOL,LIN
      GO TO 136
      END IF
      LIN=1
139   CONTINUE
      SBPLSA=(STEPB+STEPA)*0.5
      SBMNSA=DABS(STEPB-STEPA)
!     SBMNSA=ABS(STEPB-STEPA)
      IF(SBMNSA.LE.STOL*SBPLSA) THEN
      LIN=LIN-1
      WRITE(6,2028) STEP,GSTEP,GTOL,LIN
      GO TO 136
      END IF
      STEP=STEPA-GSTEPA*(STEPA-STEPB)/(GSTEPA-GSTEPB)
      DO 1391 I=1,NEQ
1391  UNEW(I)=B(I)+STEP*DR(I)
!---- INTEGRATE CONSTITUTIVE LAW
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,UNEW,M(NV),.FALSE.,.FALSE.,.FALSE.,
     3 .FALSE.)
      IF(IDIVG.EQ.999) GO TO 416
!---- FORM RIGHT HAND SIDE VECTOR DELFRC
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DELFRC,NEQ,IDPROP,PROP,NEN,NEN1,
     1 NDF,NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,DELFRC,DELFRC,DELFRC,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,6,UNEW,M(NV),.FALSE.,.TRUE.,.FALSE.,
     3 .FALSE.)
      GSTEP=DOT(DELFRC,DR,NEQ)
      GGA=GSTEP*GSTEPA
      IF(GGA.GT.0.D0) THEN
      GSTEPB=0.5*GSTEPB
      END IF
      IF(GGA.LE.0.D0) THEN
      STEPB=STEPA
      GSTEPB=GSTEPA
      END IF
      STEPA=STEP
      GSTEPA=GSTEP
      LIN=LIN+1
      IF((DABS(GSTEP).GT.GTOL).AND.(LIN.LE.LINMAX)) GO TO 139
!     IF((ABS(GSTEP).GT.GTOL).AND.(LIN.LE.LINMAX)) GO TO 139
      LIN=LIN-1
      WRITE(6,2028) STEP,GSTEP,GTOL,LIN
136   CONTINUE
      ENRG=ENRG*STEP
      DO 133 N = 1,NEQ
133   B(N) = B(N) + STEP*DR(N)
      GO TO 330

!---- MACRO 'LMAS'
!---- FORM A LUMPED MASS APPROXIMATION
14    AFL = .FALSE.
      BFL = .TRUE.
      IF(EFL) CALL PSETM(NN,NE,NEQ*IPR,EFL)
      CALL PZERO(M(NN),NEQ)
!---- THE FOLL WAS ADDED TO PROVIDE THE FACILITY FOR CALCULATING
!---- THE EIGENVALUES OF SCALED OR UNSCALED STIFFNESS MATRIX FOR
!---- ESTIMATING THE CONDITION NUMBER (REF R.D.COOK 'CONCEPTS OF FEM')
!---- MACROS TO BE USED -
!---- 'LMAS EGKS' -- SET UP DUMMY MASS MATRIX TO CALCULATE EVALUES OF SCALED [K]
!---- 'LMAS EGKU' -- SET UP DUMMY MASS MATRIX TO CALCULATE EVALUES OF UNSCAL [K]
      XKEY0 = 4H    
      XKEY1 = 4HEGKS
      XKEY2 = 4HEGKU
      IF(CT(2,L).EQ.XKEY1) THEN
      IF(.NOT.AFR) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO LMAS ''
     1 /'' ATTEMPT TO FORM MASS MATRIX FOR COMPUTING EVALUES OF''
     2 /'' SCALED STIFF MATRIX BEFORE FORMING STIFF MATRIX'')')
      STOP
      END IF
      CALL CNDMAS(M(NA),M(NN),JDIAG,NEQ,1)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY2) THEN
      CALL CNDMAS(M(NN),M(NN),JDIAG,NEQ,2)
      GO TO 330
      END IF
!---- ALLOCATE NODAL POINT MASSES (READ IN BY MACRO MASS IN PMESH)
      IM = (NN-1)/IPR
!     DO 145 I = 1,NEQ
! 145 XRM(IM+I) = ACCELG(I)
      GO TO 140

!---- MACRO 'CMAS'
!---- FORM A CONSISTENT MASS APPROXIMATION
15    AFL = .TRUE.
      BFL = .FALSE.
      IF(DFL) CALL PSETM(NM,NE,JDIAG(NEQ)*IPR,DFL)
152   CALL PZERO(M(NM),JDIAG(NEQ))
140   CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,M(NN),M(NM),M(NM),VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,5,B,M(NV),AFL,BFL,.FALSE.,.FALSE.)
      GO TO 330

!---- MACRO 'MESH'
!---- READ IN NEW MESH
   16 CONTINUE
      I = -1
      CALL PMESH(LD,XL,PDIST,IDIST,S,IE,D,ID,X,IX,IDPROP,F,T,DR,STR,
     1 EPS,Q,VEL,ACCEL,NDF,NDM,NEN1,NSTR,NQ,NST,NDIST,I,PRT)
      IF (I.GT.0) GO TO 404
      GO TO 330

!---- MACRO 'EIGE'
!---- COMPUTE LOWEST EIGENVALUE
!---- THE PRESENT VERSION COMPUTES ANY EIGENVALUE BY INVERSE VECTOR
!---- ITERATION WITH SHIFTING. IF SHIFT=0.0 THEN LOWEST EVALUE WILL BE COMPUTED
!---- ALSO IN THE PRESENT VERSION THE INITIAL GUESS VECTOR FOR THE EVECTOR
!---- MUST BE USER-INPUT THRO MACRO 'INIT' IN PMESH.
!---- MACROS TO BE USED-
!     MACR
!     TOL       VALUE
!     TANG
!     LMAS
!     EIGE      NITMAX      SHIFT
!     END
!     STOP
17    J = NM
      IF(DFL) J = NN
      NITMAX = CT(3,L)
      SHFTEG = CT(4,L)
      IF (NITMAX.LE.0) NITMAX = 100
      CALL PEIGS(M(NA),M(J),IDPROP,PROP,F,X,B,DR,ID,IX,
     1 JDIAG,NDF,NDM,NEN1,DFL,AFR,TOL,NITMAX,SHFTEG)

!---- TRANSFER EIGEN VECTOR DR TO DISPL VECTOR B FOR PLOTTING
      DO 9914 IEQ=1,NEQ
      IF(ID(IEQ).EQ.0) THEN
      B(IEQ) = DR(IEQ)
      ELSE
      B(IEQ) = 0.D0
      END IF
9914  CONTINUE
!
      GO TO 330

!---- MACRO 'PLOT'
   18 CONTINUE
      KKEY = CT(3,L)
      IF (KKEY.EQ.1) KEY = 0
      IF (KKEY.NE.1) KEY = 1
      IQ = CT(4,L)
!---- FOR INTERFACE WITH G-SAFE POST PROCESSOR REQUIRE COORDS OF GAUSS-POINTS
!  GET X,Y COORDINATES OF ALL INTEGRATION POINTS OF ALL ELEMENTS
!  AND STORE THEM AS EPSL(1,IQUAD) AND EPSL(2,IQUAD)
!      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
!    1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
!    2   NDF,NDM,NEN1,NST,NSTR,NQ,8,B,M(NV),.FALSE.,.FALSE.,
!    3   .FALSE.,.FALSE.)

      CALL PLOT(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,F,T,JDIAG,STR,EPS,Q,B,DR,
     1 VELG,ACCELG,VEL,ACCEL,NDF,NDM,NEN1,NST,NSTR,NQ,NEND,KEY,IQ,PRT)
      GO TO 330

!---- MACRO 'REAC'
!---- COMPUTE REACTIONS AND PRINT
20    CALL PZERO(DR,NEQ)
      CALL PFORM2(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.TRUE.)
      CALL PRTREA(DR,ID,NDF)
      GO TO 330

!---- MACRO 'CHEC'
!---- CHECK MESH FOR INPUT ERRORS
21    CONTINUE
      CRVVF = CT(3,L)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,10,B,F,
     3   .FALSE.,.FALSE.,.FALSE.,.FALSE.)
      GO TO 330

!---- MACRO 'PRIN'
!---- TURN ON PRINT OPTION
22    PFR = .TRUE.
      GO TO 330

!---- MACRO 'NOPR'
!---- TURN OFF PRINT OPTION
23    PFR = .FALSE.
      GO TO 330

!---- MACRO 'RATE'
!---- EXPLICIT ALGORITHM FOR PARABOLIC EQUATIONS
24    CONTINUE
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
      IF (NN.EQ.0) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO RATE''
     1 /'' LUMPED MASS MATRIX HAS NOT BEEN PREVIOUSLY COMPUTED'')')
      STOP
      END IF
      IM = (NN-1)/IPR
      DO 241 I = 1,NEQ
      IF (ID(I).EQ.0) THEN
      VELG(I) = DR(I)/XRM(IM+I)
      ELSE
      VELG(I) = 0.D0
      END IF
  241 CONTINUE
      GO TO 330

!---- MACRO 'RESE'
!---- RESET VALUE OF SELECTED INTERNAL VARIABLE
25    CONTINUE
      IQ = CT(3,L)
      QNEW = CT(4,L)
      CALL RESETQ(Q,QNEW,IQ,NUMEL,NQUAD,NQDM)
      GO TO 330

!---- MACRO 'EMAX'
!---- COMPUTE MAXIMUM EIGENFREQUENCY/EIGENMODE BY FORWARD VECTOR ITERATION
!---- WARNING: CONVERGENCE MAY BE SLOW FOR LARGE SYSTEMS.
!---- COUNTER CHECK MAX EVALUE GIVEN BY 'EMAX' USING 'EIGE' WITH APPROPRIATE
!---- SHIFT. IN THE PRESENT VERSION THE INITIAL GUESS VECTOR 'B' IS USER-INPUT
!---- THRO MACRO 'INIT' IN PMESH
!---- THE PRESENT VERSION FORMS {DR}=[K]{B} BY DIRECT MULTIPLICATION (SUBROUTINE
!---- PROMUL). HENCE PRIOR FORMING OF [K] MATRIX IS NECCESARY.
!---- MACROS TO BE USED
!     MACR
!     TOL          VALUE
!     TANG
!     LMAS
!     EMAX         NITMAX
!     END
!     STOP
26    CONTINUE
      IM = (NN-1)/IPR
      IF (NN.EQ.0) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO EMAX ''
     1 /'' LUMPED MASS MATRIX HAS NOT BEEN PREVIOUSLY COMPUTED'')')
      STOP
      END IF
!---- FOLL WAS ADDED ON OCT 24,1988. CHECK IF 'TANG' HAS BEEN PREVIOUSLY DONE
      IF(.NOT.AFR) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO EMAX ''
     1 /'' STIFFNESS MATRIX HAS NOT BEEN PREVIOUSLY COMPUTED'')')
      STOP
      END IF

      DO 263 IEQ = 1,NEQ
      IM = IM + 1
      IF (ID(IEQ).EQ.0) THEN
      IF (XRM(IM).EQ.0.D0) THEN
      WRITE(6,'(///'' SYSTEM HAS INFINITE EIGENVALUE(S)''/)')
      STOP
      END IF
!---- FOLL WAS ADDED TO SET UP INITIAL GUESS VECTOR 'B' (CORR TO MAX EVALUE)
!---- AS DIAGONAL TERMS OF MASS MATRIX
!     B(IEQ) = XRM(IM)
      ELSE
      DR(IEQ) = 0.D0
!---- FOLL WAS ADDED TO RESET DOFS CORRESPONDING TO FIXED SUPPORTS TO
!---- ZERO IN GUESS VECTOR 'B'
      B(IEQ) = 0.D0
      END IF
  263 CONTINUE
!     PRSAVE = PROP
!     PROP = 0.0
      DO 264 I=1,7
      PRSAVE(I)=PROP(I)
  264 PROP(I)=0.D0
      NITMAX = CT(3,L)
      IF (NITMAX.LE.0) NITMAX = 100
      ENEW = 1.D0
      IF (PFR) WRITE(6,'('' EIGENVALUE = '',E15.5)') ENEW
      EMAX = 1.D0
      NIT = 0
  260 CONTINUE
!---- THE FOLL CARDS WERE COMMENTED OUT TO FORM {DR} = [K]{B} DIRECTLY BY
!---- CALLING SUBROUTINE PROMUL. THIS REQUIRES PRIOR USE OF 'TANG'.
!---- IN OLD VERSION {DR} = -[K]{B} = INTEGRAL OF [BT]{SIG} DV.(ISW=9 + ISW=6)
!     CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
!    1 STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
!    2 NDF,NDM,NEN1,NST,NSTR,NQ,9,B,
!    3 M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
!     CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
!    1 NST,NDIST)
!     CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
!    1 STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
!    2 NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
!    3 M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)

!---- FOLL 2 CARDS WERE ADDED TO FORM {DR} = [K]{B} DIRECTLY
      CALL PZERO(DR,NEQ)
      CALL PROMUL(M(NA),B,DR,JDIAG,NEQ)
      DO 266 IEQ=1,NEQ
      DR(IEQ) = -DR(IEQ)
266   CONTINUE

      XNUM = 0.D0
      DEN = 0.D0
      XNORM = 0.D0
      IM = (NN-1)/IPR
      DO 261 IEQ = 1,NEQ
      IM = IM + 1
      IF(ID(IEQ).EQ.0) THEN
      XNUM = XNUM - B(IEQ)*DR(IEQ)
      DEN = DEN + XRM(IM)*B(IEQ)*B(IEQ)
      XNORM = XNORM + DR(IEQ)*DR(IEQ)/XRM(IM)
      DR(IEQ) = DR(IEQ)/XRM(IM)
      END IF
  261 CONTINUE
      IF ((XNORM.EQ.0.D0).OR.(DEN.EQ.0.D0)) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO EMAX''
     1 /'' ITERATION VECTOR IS NULL OR ZERO EIGENVECTOR'')')
      STOP
      END IF
      XNORM = DSQRT(XNORM)
!     XNORM = SQRT(XNORM)
      DO 262 IEQ = 1,NEQ
  262 B(IEQ) = - DR(IEQ)/XNORM
      EOLD = ENEW
      ENEW = XNUM/DEN
      IF (PFR) WRITE(6,'('' EIGENVALUE = '',E15.7)') ENEW
      IF (DABS(ENEW).GT.EMAX) EMAX = DABS(ENEW)
!     IF (ABS(ENEW).GT.EMAX) EMAX = ABS(ENEW)
      IF ((DABS(ENEW-EOLD)/EMAX).GT.TOL) THEN
!     IF ((ABS(ENEW-EOLD)/EMAX).GT.TOL) THEN
      NIT = NIT + 1
      IF (NIT.LT.NITMAX) GO TO 260
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO EMAX ''
     1 /'' CONVERGENCE HAS NOT BEEN ACHIEVED IN '',I4,'' ITERATIONS'')')
     2 NITMAX
      STOP
      END IF
      WRITE(6,'(///'' MAXIMUM EIGENVALUE = '',E15.7
     1            /'' ITERATIONS         = '',I15)') ENEW,NIT
!     PROP = PRSAVE
!---- PRINT EIGEN VECTOR
      CALL PRTDIS(ID,X,B,IDPROP,PROP,F,NDM,NDF)
      DO 265 I=1,7
  265 PROP(I)=PRSAVE(I)
      GO TO 330

!---- MACRO 'SUBS'
!---- SUBSPACE EIGENCOMPUTATIONS
27    MF = CT(3,L)
      MF = MIN0(NEQ,MAX0(1,MF))
      MQ = MIN0(MF+MF,MF+8,NEQ)
      IF(DFL) CALL NUMASS(M(NN),NEQ,MQ)
      IF(MQ.LT.MF) WRITE(6,2039) MQ
      MF = MIN0(MF,MQ)
      MB = NN
      IF(.NOT.DFL) MB = NM
      IMAS = 2
      IF(.NOT.DFL) IMAS = 1
      MV = NE
      MT = MV + MQ*NEQ*IPR
      MG = MT + NEQ*IPR
      MH = MG + MQ*(MQ+1)/2*IPR
      MD = MH + MQ*(MQ+1)/2*IPR
      MDP= MD + MQ*IPR
      MDT= MDP+ MQ*IPR
      MP = MDT+ MQ*IPR
      MZ = MP + MQ*MQ*IPR
      MS = MZ + MQ*NEQ*IPR
      CALL SETMEM(MS)
      CALL SUBSP(M(NA),M(MB),
     1 M(MV),M(MT),M(MG),
     2 M(MH),M(MD),M(MDP),
     3 M(MDT),M(MP),M(MZ),
     4 JDIAG,MF,MQ,NEQ,IMAS,TOL,CT(4,L),PRT,25)

      CALL TRNSEG(M(MV),ID,B,NEQ)

      GO TO 330

!---- MACRO 'HIST'
!---- CREATE FILES WITH SELECTED TIME HISTORIES
28    CONTINUE
!     INQUIRE(LDUMP,OPENED=DUMPFL)
!     IF(.NOT.DUMPFL) THEN
!     OPEN(LDUMP,FILE='HISTFILE',STATUS='UNKNOWN',FORM='FORMATTED')
!     END IF
      XKEY0 =4H    
      XKEY1 =4HDISP
      XKEY2 =4HVELO
      XKEY3 =4HACCE
      XKEY4 =4HSTRE
      XKEY5 =4HSTRA
      XKEY6 =4HIVAR
!---- DISPLACEMENT HISTORY
      IF ((CT(2,L).EQ.XKEY0).OR.(CT(2,L).EQ.XKEY1)) THEN
      NOD = CT(3,L)
      IDF = CT(4,L)
      KID = (NOD - 1)*NDF + IDF
      IF (ID(KID).EQ.0) THEN
      VAR = B(KID)
      ELSE
!     VAR = F(KID)*PROP
      IND=IDPROP(KID)
      VAR=F(KID)*PROP(IND)
      END IF
      WRITE(LDUMP,'(I5,2X,3E15.7)') NOD,TIME,PROP(1),VAR
      GO TO 330
      END IF
!---- VELOCITY HISTORY
      IF (CT(2,L).EQ.XKEY2) THEN
      NOD = CT(3,L)
      IDF = CT(4,L)
      KID = (NOD - 1)*NDF + IDF
      WRITE(LDUMP,'(I5,2x,2E15.7)') NOD,TIME,VELG(KID)
      GO TO 330
      END IF
!---- ACCELERATION HISTORY
      IF (CT(2,L).EQ.XKEY3) THEN
      NOD = CT(3,L)
      IDF = CT(4,L)
      KID = (NOD - 1)*NDF + IDF
      WRITE(LDUMP,'(I5,2x,2E15.7)') NOD,TIME,ACCELG(KID)
      GO TO 330
      END IF
!---- STRESS HISTORY
      IF (CT(2,L).EQ.XKEY4) THEN
      NEL = CT(3,L)
      IDF = CT(4,L)
      WRITE(LDUMP,'(I5,2x,2E15.7)') NEL,TIME,STR(IDF,NEL)
      GO TO 330
      END IF
!---- STRAIN HISTORY
      IF (CT(2,L).EQ.XKEY5) THEN
      NEL = CT(3,L)
      IDF = CT(4,L)
      WRITE(LDUMP,'(I5,2x,2E15.7)') NEL,TIME,EPS(IDF,NEL)
      GO TO 330
      END IF
!---- INTERNAL VARIABLE HISTORY
      IF (CT(2,L).EQ.XKEY6) THEN
      NEL = CT(3,L)
      IDF = CT(4,L)
      WRITE(LDUMP,'(I5,2x,2E15.7)') NEL,TIME,Q(IDF,NEL)
      GO TO 330
      END IF

!     MACRO 'RESF'
29    CONTINUE

      XKR =4HREAD
      XKW =4HWRIT
      IF (CT(2,L).EQ.XKR) THEN
      REWIND LRESF
      READ (LRESF,'(6(1PE13.5)/2(1PE13.5),4I5)') TIME,(PROP(I),I=1,7)
     1 ,NEQP,NUMELP,NSTRP,NQP
      IF (NEQP.GT.NEQ) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO RESF/READ''
     1 /'' CURRENT MODEL HAS LESS DEGREES OF FREEDOM THAN''
     2 /'' PREVIOUS MODEL'')')
      STOP
      END IF
      IF (NUMELP.GT.NUMEL) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO RESF/READ''
     1 /'' CURRENT MODEL HAS LESS ELEMENTS THAN PREVIOUS MODEL'')')
      STOP
      END IF
      IF (NSTRP.NE.NSTR) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO RESF/READ''
     1 /'' NUMBER OF QUADRATURE POINTS PER ELEMENT AND/OR''
     2 /'' DIMENSIONALITY OF STRESS/STRAIN ARRAYS IN CUR-''
     3 /'' RENT MODEL DO NOT MATCH THOSE FROM PREVIOUS ONE'')')
      STOP
      END IF
      IF (NQP.NE.NQ) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO RESF/READ''
     1 /'' NUMBER OF QUADRATURE POINTS PER ELEMENT AND/OR''
     2 /'' DIMENSIONALITY OF INTERNAL VARIABLE ARRAY IN CUR-''
     3 /'' RENT MODEL DO NOT MATCH THOSE FROM PREVIOUS ONE'')')
      STOP
      END IF
      READ (LRESF,'(6(1PE13.5))') (B(I),I=1,NEQP),(VELG(I),I=1,NEQP),
     1              (ACCELG(I),I=1,NEQP)
      DO 291 J = 1,NUMELP
      READ (LRESF,'(6(1PE13.5))')  (STR(I,J),I=1,NSTRP),
     1              (EPS(I,J),I=1,NSTRP),
     2              (Q(I,J),I=1,NQP)
 291  CONTINUE
1     IF(NSLAV.GT.0) THEN
!_    READ (LRESF,'(15I5)') (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),
!_   1 J=1,NSLAV)
!     READ (LRESF,'(15I5)') (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),
!    1 J=1,50)
!_    READ (LRESF,'(6(1PE13.5))') (CP(1,J),CP(2,J),BET(J),DEL(1,J),
!_   1DEL(2,J),J=1,NSLAV),(ANG(J),J=1,NMAST-1)
!     READ (LRESF,'(6(1PE13.5))') (CP(1,J),CP(2,J),BET(J),DEL(1,J),
!    1DEL(2,J),J=1,50),(ANG(J),J=1,50)
!     END IF
!     IF(NSURF .GT. 0) THEN
!     READ(LRESF,'(15I5)')(NDSURF(I),I=1,NSURF)
!     READ(LRESF,'(6(1PE13.5))')(CPSURF(1,J),CPSURF(2,J),J=2,NSURF)
!     ENDIF
!     IF(NINTND .GT. 0) THEN
!     READ(LRESF,'(6(1PE13.5))')(CPINT(1,J),CPINT(2,J),J=1,NINTND)
!     READ(LRESF,'(15I5)')(ISTAT(I),I=1,NINTND)
!     READ(LRESF,'(6(1PE13.5))')(XLN(I),I=1,NINTND)
!     END IF
      WRITE(6,2034) TIME
      WRITE(6,2035) (PROP(I),I=1,7)
      END IF
      IF (CT(2,L).EQ.XKW) THEN
!---- IF REQUESTED, RESTART INFORMATION IS ALWAYS WRITTEN AT THE END OF LAST
!---- TIME STEP. OPTION IS PROVIDED TO WRITE RESTART FILE EVERY N=CT(3,L) STEPS.
      LX=LVE(LV)
      L0=LVS(LV)
      IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.0D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.0D0) GO TO 330
      END IF
      WRITE(6,2017) TIME,TIMSTP
      WRITE(6,2035) (PROP(I),I=1,7)
      REWIND(LRESF)
      WRITE (LRESF,'(6(1PE13.5)/2(1PE13.5),4I5)') TIME,(PROP(I),I=1,7)
     1 ,NEQ,NUMEL,NSTR,NQ
      WRITE (LRESF,'(6(1PE13.5))') (B(I),I=1,NEQ),(VELG(I),I=1,NEQ),
     1      (ACCELG(I),I=1,NEQ)
      DO 292 J = 1,NUMEL
      WRITE (LRESF,'(6(1PE13.5))') (STR(I,J),I=1,NSTR),
     1      (EPS(I,J),I=1,NSTR),(Q(I,J),I=1,NQ)
  292 CONTINUE
!     IF(NSLAV.GT.0) THEN
!_    WRITE (LRESF,'(15I5)') (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),
!_   1J=1,NSLAV)
!     WRITE (LRESF,'(15I5)') (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),
!    1J=1,50)
!_    WRITE (LRESF,'(6(1PE13.5))') (CP(1,J),CP(2,J),BET(J),DEL(1,J),
!_   1 DEL(2,J),J=1,NSLAV),(ANG(J),J=1,NMAST-1)
!     WRITE (LRESF,'(6(1PE13.5))') (CP(1,J),CP(2,J),BET(J),DEL(1,J),
!    1 DEL(2,J),J=1,50),(ANG(J),J=1,50)
!     END IF
!     IF(NSURF .GT. 0) THEN
!     WRITE(LRESF,'(15I5)')(NDSURF(I),I=1,NSURF)
!     WRITE(LRESF,'(6(1PE13.5))')(CPSURF(1,J),CPSURF(2,J),J=2,NSURF)
!     ENDIF
!     IF(NINTND .GT. 0) THEN
!     WRITE(LRESF,'(6(1PE13.5))')(CPINT(1,J),CPINT(2,J),J=1,NINTND)
!     WRITE(LRESF,'(15I5)')(ISTAT(I),I=1,NINTND)
!     WRITE(LRESF,'(6(1PE13.5))')(XLN(I),I=1,NINTND)
!     END IF
      END IF
      GO TO 330

!---- MACRO 'PRED'
!---- NEWMARK/MIDPOINT RULE PREDICTORS
   31 CONTINUE
      IF (.NOT.TFL) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO PRED''
     1 /'' ALGORITHM PARAMETERS HAVE NOT BEEN PREVIOUSLY DEFINED'')')
      END IF
      XKEY0 =4H    
      XKEY1 =4H2ND 
      XKEY2 =4H1ST 
      IF ((CT(2,L).EQ.XKEY0).OR.(CT(2,L).EQ.XKEY1)) THEN
      COEF = (0.5 - BETA)*DT*DT
      DO 309 INP = 1,NEQ
      IF (ID(I).EQ.0)
     1 B(INP) = B(INP) + DT*VELG(INP) + COEF*ACCELG(INP)
  309 CONTINUE
      COEF = (1.D0 - GAMMA)*DT
      DO 311 I = 1,NEQ
      IF (ID(I).EQ.0) VELG(I) = VELG(I) + COEF*ACCELG(I)
  311 CONTINUE
      DO 312 I = 1,NEQ
      ACCELG(I) = 0.D0
  312 CONTINUE
      END IF
      IF (CT(2,L).EQ.XKEY2) THEN
      COEF = (1.D0 - BETA)*DT
      KOUNT = 0
      DO 313 I = 1,NEQ
      IF (ID(I).EQ.0) THEN
      B(I) = B(I) + COEF*VELG(I)
      ELSE
      IND=IDPROP(I)
      B(I) = PROP(IND)*F(I)
      END IF
  313 CONTINUE
      DO 314 I = 1,NEQ
  314 VELG(I) = 0.D0
      END IF
      GO TO 330

!---- MACRO 'PARA'
   32 CONTINUE
      BETA = CT(3,L)
      GAMMA = CT(4,L)
      TFL = .TRUE.
      GO TO 330

!---- MACRO 'EXCH'
   33 CONTINUE
      IF (NN.EQ.0) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO EXCH''
     1 /'' LUMPED MASS MATRIX HAS NOT BEEN PREVIOUSLY COMPUTED'')')
      STOP
      END IF
      DO 331 I = 1,NEQ
  331 B(I) = B(I) + DT*VELG(I)
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
      IM = (NN-1)/IPR
      DO 335 I = 1,NEQ
  335 VELG(I) = DR(I)/XRM(IM+I)
      GO TO 330

!---- MACRO 'EXCD'
!---- EXPLICIT NEWMARK SCHEME (BETA = 0)
!---- THE VALUE OF GAMMA IS INPUT THRO MACRO 'PARA'
!---- IF (ALFA.NE.0.0) THE FOLLOWING ALGORITM CORRESPONDS TO THE
!---- EXPLICIT HUGHES-HILBER-TAYLOR SCHEME
!---- INITIAL NODAL DISPLACEMENTS AND VELOCITIES ARE DEFINED EARLIER
!---- USING MACROS INIT AND VELO. IF NOT DEFINED, THESE WILL BE TAKEN
!---- AS ZERO.
!---- SUGGESTED SET OF MACRO COMANDS:
!     PATH DEPD
!     PROP
!     PARA         BETA         GAMMA
!     DT
!     LMAS
!     CEQS
!     ACCE
!     LOOP            N
!     TIME
!     EXCD         ALFA
!     NEXT
   34 CONTINUE
      ALFA = CT(3,L)
      IF(.NOT.TFL) GAMMA = 0.5
!---- LOAD/DISP TERMS
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
!     CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
!    1 NST,NDIST)
!---- UPDATE DISPLACEMENTS
      DTH = DT*0.5
      DT2 = DT*DTH
!---------------------------------------------------------------------------------------------------------
!$ACC REGION

      DO 390 I=1,NEQ
      B1 = B(I)
      IF(ID(I).EQ.0) THEN
      B(I) = B(I) + DT*VELG(I)+DT2*ACCELG(I)
      ELSE
      IND = IDPROP(I)
      B(I) = F(I)*PROP(IND)
      END IF
      UNEW(I) = B(I) - B1
390   CONTINUE

!$ACC END REGION
!---------------------------------------------------------------------------------------------------------

!---- INTEGRATE CONSTITUTIVE EQNS
      CALL PFORM_SWAPNIL(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,
     1 PROP,F,T,JDIAG, STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2 NDF,NDM,NEN1,NST,NSTR,NQ,9,B,
     3 UNEW,.FALSE.,.FALSE.,.FALSE.,.FALSE.)
!---- FORM RHS
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      CALL PFORM22(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,
     1   JDIAG,STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   UNEW,.FALSE.,.TRUE.,.FALSE.,.FALSE.)
!---- SOLVE FOR ACCELERATIONS
      IM   = (NN-1)/IPR

!---------------------------------------------------------------------------------------------------------
!$ACC REGION

      DO 395 I = 1,NEQ
      ACC = ACCELG(I)
      IF((ID(I).EQ.0).AND.(XRM(IM+I).GT.0.D0)) THEN
      ACCELG(I) = ((1.D0 + ALFA)*DR(I) - ALFA*OLDFRC(I))/XRM(IM+I)
      OLDFRC(I) = DR(I)
!     ACCELG(I) = DR(I)/XRM(IM+I)
      VELG(I) = VELG(I) + DT*(GAMMA*ACCELG(I) + (1.D0-GAMMA)*ACC)
!     VELG(I)   = VELG(I)+DTH*(ACCELG(I)+ACC)
      ELSE
      VELPRV = VELG(I)
      VELG(I) = UNEW(I)/DT
      ACCELG(I) = (VELG(I)-VELPRV)/DT
      END IF
395   CONTINUE

!$ACC END REGION
!---------------------------------------------------------------------------------------------------------

      GO TO 330

!---- MACRO 'CORR'
!---- NEWMARK/MIDPOINT RULE CORRECTORS
   35 CONTINUE
      IF (.NOT.TFL) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO CORR''
     1 /'' ALGORITHM PARAMETERS HAVE NOT BEEN PREVIOUSLY DEFINED'')')
      END IF
      XKEY0 =4H    
      XKEY1 =4H2ND 
      XKEY2 =4H1ST 
      IF ((CT(2,L).EQ.XKEY0).OR.(CT(2,L).EQ.XKEY1)) THEN
!     DPROP = PROP - PROPOL
      DO 351 I=1,7
351   DPROP(I)=PROP(I)-PROPOL(I)
      CA = 1.D0/(BETA*DT*DT)
      CV = GAMMA/(BETA*DT)
      DO 350 I = 1,NEQ
      IF (ID(I).EQ.0) THEN
      ACCELG(I) = ACCELG(I) + CA*DR(I)
      VELG(I) = VELG(I) + CV*DR(I)
      END IF
  350 CONTINUE
      END IF
      IF (CT(2,L).EQ.XKEY2) THEN
      CV = 1./(BETA*DT)
      DO 355 I = 1,NEQ
      IF (ID(I).EQ.0) THEN
      VELG(I) = VELG(I) + CV*DR(I)
      ELSE
      VELG(I) = 0.D0
      END IF
  355 CONTINUE
      END IF
      GO TO 330

!---- MACRO 'CPU '
!---- SHOW CPU TIME FROM BEGINNING OF EXECUTION
   36 CONTINUE
!     CALL LIB$SHOW_TIMER(CPUTIME,2,WATCH,0)
      GO TO 330

!---- MACRO 'REST'
!---- DUMP AND RETRIEVE FROM TAPE RELEVANT INFORMATION FOR A RESTART
   37 CONTINUE
      REWIND(LREST)
      XKR =4HREAD
      XKW =4HWRIT
      IF (CT(2,L).EQ.XKR) THEN
      READ (LREST) TIME,(PROP(I),I=1,7),NEQP,NUMELP,NSTRP,NQP
      IF (NEQP.GT.NEQ) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO REST/READ''
     1 /'' CURRENT MODEL HAS LESS DEGREES OF FREEDOM THAN''
     2 /'' PREVIOUS MODEL'')')
      STOP
      END IF
      IF (NUMELP.GT.NUMEL) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO REST/READ''
     1 /'' CURRENT MODEL HAS LESS ELEMENTS THAN PREVIOUS MODEL'')')
      STOP
      END IF
      IF (NSTRP.NE.NSTR) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO REST/READ''
     1 /'' NUMBER OF QUADRATURE POINTS PER ELEMENT AND/OR''
     2 /'' DIMENSIONALITY OF STRESS/STRAIN ARRAYS IN CUR-''
     3 /'' RENT MODEL DO NOT MATCH THOSE FROM PREVIOUS ONE'')')
      STOP
      END IF
      IF (NQP.NE.NQ) THEN
      WRITE(6,'(/'' **ERROR** DETECTED BY MACRO REST/READ''
     1 /'' NUMBER OF QUADRATURE POINTS PER ELEMENT AND/OR''
     2 /'' DIMENSIONALITY OF INTERNAL VARIABLE ARRAY IN CUR-''
     3 /'' RENT MODEL DO NOT MATCH THOSE FROM PREVIOUS ONE'')')
      STOP
      END IF
      READ (LREST) (B(I),I=1,NEQP),(VELG(I),I=1,NEQP),
     1 (ACCELG(I),I=1,NEQP)
      DO 371 J = 1,NUMELP
      READ (LREST) (STR(I,J),I=1,NSTRP)
      READ (LREST) (EPS(I,J),I=1,NSTRP)
      READ (LREST) (Q(I,J),I=1,NQP)
  371 CONTINUE
!     IF(NSLAV.GT.0) THEN
!_    READ (LREST) (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),J=1,NSLAV)
!_    READ (LREST) (CP(1,J),CP(2,J),BET(J),DEL(1,J),DEL(2,J),
!_   1 J=1,NSLAV),(ANG(J),J=1,NMAST-1)
!     READ (LREST) (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),J=1,50)
!     READ (LREST) (CP(1,J),CP(2,J),BET(J),DEL(1,J),DEL(2,J),
!    1 J=1,50),(ANG(J),J=1,50)
!     END IF
!     IF(NSURF .GT. 0) THEN
!     READ(LREST)(NDSURF(I),I=1,NSURF)
!     READ(LREST)(CPSURF(1,J),CPSURF(2,J),J=2,NSURF)
!     ENDIF
!     IF(NINTND .GT. 0) THEN
!     READ(LREST)(CPINT(1,J),CPINT(2,J),J=1,NINTND)
!     READ(LREST) (ISTAT(I),I=1,NINTND)
!     READ(LREST) (XLN(I),I=1,NINTND)
!     END IF
      WRITE(6,2034) TIME
      WRITE(6,2035) (PROP(I),I=1,7)
      END IF
      IF (CT(2,L).EQ.XKW) THEN
!---- IF REQUESTED, RESTART INFORMATION IS ALWAYS WRITTEN AT END OF LAST TIME
!---- STEP. OPTION IS PROVIDED TO WRITE RESTART FILE EVERY N=CT(3,L) STEPS.
!     LX=LVE(LV)
!     L0=LVS(LV)
!     IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.0D0) GO TO 330
!     EMOD2=AMAX1(CT(3,L),1.E0)
!     IF(AMOD(CT(3,LX),EMOD2).NE.0.0E0) GO TO 330
!     END IF
      WRITE(6,2017) TIME,TIMSTP
      WRITE(6,2035) (PROP(I),I=1,7)
      NUMNP1 = NUMNP
      NUMEL1 = NUMEL
      NEQ1 = NEQ
!--------------------------------------------------------------
      IF(CT(3,L).GT.0.D0) THEN
      NUMNP1 = CT(3,L)
      NUMEL1 = CT(4,L)
      NEQ1 = NDF*NUMNP1 
      NEQ2 = NEQ - NEQ1
      NUMNP2 = NUMNP - NUMNP1
      NUMEL2 = NUMEL - NUMEL1
      LREST1 = 91 
      OPEN(UNIT=91,FILE='fprst1.dat',FORM='UNFORMATTED',    
     1 ACCESS='SEQUENTIAL')
      REWIND LREST1
      END IF
!----------------------------------------------------------------
      REWIND LREST
      WRITE (LREST) TIME,(PROP(I),I=1,7),NEQ1,NUMEL1,NSTR,NQ
      WRITE (LREST) (B(I),I=1,NEQ1),(VELG(I),I=1,NEQ1),
     1 (ACCELG(I),I=1,NEQ1)
      DO 372 J = 1,NUMEL1
      WRITE (LREST) (STR(I,J),I=1,NSTR)
      WRITE (LREST) (EPS(I,J),I=1,NSTR)
      WRITE (LREST) (Q(I,J),I=1,NQ)
  372 CONTINUE
!     IF(NSLAV.GT.0) THEN
!_    WRITE (LREST) (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),J=1,NSLAV)
!_    WRITE (LREST) (CP(1,J),CP(2,J),BET(J),DEL(1,J),DEL(2,J),
!_   1 J=1,NSLAV),(ANG(J),J=1,NMAST-1)
!     WRITE (LREST) (IAB(1,J),IAB(2,J),MSEG(J),NDEST(J),J=1,50)
!     WRITE (LREST) (CP(1,J),CP(2,J),BET(J),DEL(1,J),DEL(2,J),
!    1 J=1,50),(ANG(J),J=1,50)
!     END IF
!     IF(NSURF .GT. 0) THEN
!     WRITE(LREST)(NDSURF(I),I=1,NSURF)
!     WRITE(LREST)(CPSURF(1,J),CPSURF(2,J),J=2,NSURF)
!     ENDIF
!     IF(NINTND .GT. 0) THEN
!     WRITE(LREST)(CPINT(1,J),CPINT(2,J),J=1,NINTND)
!     WRITE(LREST) (ISTAT(I),I=1,NINTND)
!     WRITE(LREST) (XLN(I),I=1,NINTND)
!     END IF
!----------------------------------------------------------------
      IF(CT(3,L).GT.0.D0) THEN
      WRITE (LREST1) TIME,(PROP(I),I=1,7),NEQ2,NUMEL2,NSTR,NQ
      WRITE (LREST1) (B(I),I=NEQ1+1,NEQ),(VELG(I),I=NEQ1+1,NEQ),
     1 (ACCELG(I),I=NEQ1+1,NEQ)
      DO 373 J = NUMEL1+1,NUMEL
      WRITE (LREST1) (STR(I,J),I=1,NSTR)
      WRITE (LREST1) (EPS(I,J),I=1,NSTR)
      WRITE (LREST1) (Q(I,J),I=1,NQ)
  373 CONTINUE
      END IF
!------------------------------------------------------------------
      END IF
      GO TO 330

!---- MACRO 'ACCE'
!---- COMPUTES ACCELERATION ARRAY BY EQUILIBRIUM
   38 CONTINUE
      IF(NPLD.GT.0) CALL PROPLD(TTABLE,PTABLE,PROP,TIME,NPLD)
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      CALL PFORM2(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
      IF (NN.EQ.0) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO ACCE''
     1 /'' LUMPED MASS MATRIX HAS NOT BEEN PREVIOUSLY COMPUTED'')')
      STOP
      END IF
      IM = (NN-1)/IPR
      DO 380 I = 1,NEQ
      IF ((ID(I).EQ.0).AND.(XRM(IM+I).GT.0.D0)) THEN
      ACCELG(I) = DR(I)/XRM(IM+I)
      ELSE
      ACCELG(I) = 0.D0
      END IF
  380 CONTINUE
      GO TO 330

!---- MACRO 'MA01'
   39 CONTINUE
!     XKEY0 = 4HFULL
!     ITMFLG = 1
!     IF(CT(2,L).EQ.XKEY0) ITMFLG = 2
!     TEMPRS = 0.0
!     XTMPR = CT(3,L)
!     YTMPR = CT(4,L)
!     IELTMP = CT(3,L)
!     NELTMP = CT(4,L)
!      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
!    1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
!    2   NDF,NDM,NEN1,NST,NSTR,NQ,11,B,M(NV),.FALSE.,.FALSE.,
!    3   .FALSE.,.FALSE.)
!     WRITE(6,3901) XTMPR,YTMPR,TEMPRS
!3901  FORMAT(//,5X,'X=',E13.5,2X,'Y=',E13.5,2X,'DELTA T=',E13.5)
      XKEY0 = 4HSHEL
      IF(CT(2,L).EQ.XKEY0) THEN
!---- use incremental displacements from previous converged time step
      do 391 i=1,neq
      delfrc(i) = delfrc(i) + dr(i)
      dr(i) = delfrc(i)
      accelg(i) = unew(i)
      velg(i) = wvect(i)
391   continue
      end if
      CALL MA01(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,F,T,JDIAG,
     1 STR,EPS,Q,B,DR,VELG,ACCELG,VEL,ACCEL,CT(2,L),
     2 NDF,NDM,NEN1,NST,NSTR,NQ,NEND,MAFL01)
      GO TO 330

!---- MACRO 'MA02'
   41 CONTINUE
      CALL MA02(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,F,T,JDIAG,
     1 STR,EPS,Q,B,DR,VELG,ACCELG,VEL,ACCEL,CT(2,L),
     2 NDF,NDM,NEN1,NST,NSTR,NQ,NEND,MAFL02)
      GO TO 330

!---- MACRO 'MA03'
   42 CONTINUE
      CALL MA03(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,F,T,JDIAG,
     1 STR,EPS,Q,B,DR,VELG,ACCELG,VEL,ACCEL,CT(2,L),
     2 NDF,NDM,NEN1,NST,NSTR,NQ,NEND,MAFL03)
!---- SET SWITCH TO INDICATE TYPE OF PATH DETERMINATION IN INTEGRATION
!---- OF CONSTITUTIVE LAW. DEFAULT IS PATH INDEP STATE DETERMINATION.
!     XKEY0=4H    
!     XKEY1=4HINDP
!     XKEY2=4HDEPD
!     IPATH=0
!     IF(CT(2,L).EQ.XKEY2) IPATH=1
      GO TO 330

!-----------------------------------------------------------------------
!---- THE FOLLOWING SEGMENT WAS ADDED BY R.NARASIMHAN ON FEB 20,1987.
!---- MACRO 'BFGS'
43    CONTINUE
!---- QUASI-NEWTON METHOD TO FIND NEW SOLUTION VECTOR DR.
!---- ADAPTED FROM H.MATHIES AND G.STRANG, INT.J.NUM.METH.ENGG.,1979,P.1613.
!---- SHOULD HAVE PERFORMED LINE SEARCH PREVIOUSLY.
!---- PROPOSED MACRO COMMANDS FOR STATIC, NONLINEAR PROBLEMS:
!---- TANG
!---- LOOP ITRN          N
!---- FORM
!---- SOLV LSRC
!---- CONV
!---- LOOP              15
!---- BFGS
!---- LSRC
!---- CONV
!---- NEXT
!---- NEXT
!---- CEQS

!---- NOTE 1) SUGGESTED VALUE FOR N: 1-4
!---- NOTE 2) INSTEAD OF USING TANG BEFORE LOOP, IT CAN BE USED AFTER LOOP.
!---- NOTE 3) BLOK CAN BE USED WITH TANG TO BLOCK LARGE STIFF MATRICES.
!---- NOTE 4) AUTO CAN BE USED WITH CONV TO USE AUTO-STEPPING.

!---- WITH GSTEP=DR*DELFRC AND GSTEP0=DR*OLDFRC WE COMPUTE:
!---- DELGAM = DELTA * GAMMA = STEP*(DR*(OLDFRC-DELFRC)) = STEP*(GSTEP0-GSTEP)
!---- DELKDL = DELTA*K(DELTA)=(STEP**2)*(DR*OLDFRC)=(STEP**2)*GSTEP0

      DELGAM=STEP*(GSTEP0-GSTEP)
      DELKDL=STEP*STEP*GSTEP0
      REWIND NBFGS
      IF (NUMUPD.GT.0) THEN
      DO 4301 I=1,NUMUPD
      READ(NBFGS)
4301  CONTINUE
      END IF
      UPDATE = .FALSE.
!---- PERFORM BFGS UPDATE ONLY IF DELGAM > 0.0 AND DELKDL > 0.0
      IF ((DELGAM.GT.0.D0).AND.(DELKDL.GT.0.D0)) UPDATE=.TRUE.
      IF (.NOT.UPDATE) THEN
      DO 431 I=1,NEQ
      DR(I)=DELFRC(I)
      OLDFRC(I)=DELFRC(I)
431   CONTINUE
      GO TO 436
      END IF

      FACT1=1.D0+STEP*DSQRT(DELGAM/DELKDL)
!     FACT1=1.0+STEP*SQRT(DELGAM/DELKDL)
      FACT2=STEP/DELGAM
      DRNORM=0.D0
      DO 432 I=1,NEQ
432   DRNORM=DRNORM+DR(I)*DR(I)
      DRNORM=STEP*DSQRT(DRNORM)
!     DRNORM=STEP*SQRT(DRNORM)
!---- COMPUTE UPDATING VECTORS VVECT AND WVECT. VVECT(1) AND DELFRC(1) HAVE
!---- THE SAME ADDRESS. (I.E.) VVECT AND DELFRC OCCUPY THE SAME STORAGE SPACE.
!---- PUT DELFRC IN DR.
      DO 433 I=1,NEQ
      AUXVEC=DELFRC(I)
      VVECT(I)=AUXVEC-FACT1*OLDFRC(I)
      WVECT(I)=DR(I)
      DR(I)=AUXVEC
      OLDFRC(I)=AUXVEC
433   CONTINUE

!---- CHECK ESTIMATE ON INCREASE OF CONDITION NUMBER (VV=V*V WW=W*W
!---- VW4=4*V*W+4)
!---- REF: K.W.BRODLIE ET.AL.,J.INST.MATH.APPL.,11,1973,PP.73-82.
      VV=0.D0
      DO 434 I=1,NEQ
434   VV=VV+VVECT(I)*VVECT(I)
      WW1=DRNORM/DELGAM
      WW=WW1*WW1
      VW4=4.D0*FACT2*(GSTEP-FACT1*GSTEP0)+4.D0
      IF(VW4.EQ.0.D0) THEN
      UPDATE=.FALSE.
      GO TO 436
      END IF
      ARG1=VV*WW
      ARG2=DABS(ARG1+VW4)
!     ARG2=ABS(ARG1+VW4)
      ARG3=DSQRT(ARG1)+DSQRT(ARG2)
!     ARG3=SQRT(ARG1)+SQRT(ARG2)
      ESTCND=(ARG3*ARG3)/(DABS(VW4))
!     ESTCND=(ARG2*ARG3)/(ABS(VW4))
!---- ESTCND IS AN UPPER BOUND FOR INCREASE IN CONDITION
!---- NUMBER OF K DUE TO BFGS UPDATE. AN UPDATE WILL BE PERFORMED
!---- ONLY IF ESTCND < CNDMAX, WHERE CNDMAX IS CURRENTLY SET AT 1.0E+05.
      IF (ESTCND.GE.CNDMAX) THEN
      UPDATE=.FALSE.
      GO TO 436
      END IF
      NUMPD1=NUMUPD+1
      WRITE(6,2031) NUMPD1

!---- SAVE UPDATING FACTORS, WITH FACT2, TO BE INCLUDED LATER IN WVECT.
      WRITE (NBFGS) NUMPD1,FACT2,VVECT,WVECT
      BACKSPACE NBFGS
!---- FORM RIGHTMOST FACTOR
      DO 435 I=1,NEQ
435   DR(I)=DR(I)+FACT2*GSTEP*VVECT(I)
!---- RIGHT HALF OF UPDATING
436   CONTINUE
      IF (NUMUPD.GT.0) THEN
      DO 437 I=1,NUMUPD
      BACKSPACE NBFGS
      READ(NBFGS) K,FACT2,VVECT,WVECT
      BACKSPACE NBFGS
      FACT3=0.D0
      DO 4371 JJ=1,NEQ
4371  FACT3=FACT3+WVECT(JJ)*DR(JJ)
      DO 4372 J=1,NEQ
4372  DR(J)=DR(J)+FACT2*FACT3*VVECT(J)
437   CONTINUE
      END IF
!---- BACK SUBSTITUTION
      IF (.NOT.BLKFL)
     1 CALL ACTCOL(M(NA),DR,JDIAG,NEQ,.FALSE.,.TRUE.)
      IF (BLKFL) THEN
      CALL PZERO(M(NA),LBLOK)
      CALL PZERO(M(NA2),LBLOK)
      CALL PSWITCH(M(NA),DR,NEQ)
      CALL OPTBLOK(M(NA),M(NA2),M(NA2),M(NA3),AVDIAG,NEQ,2)
      CALL PSWITCH(DR,M(NA),NEQ)
      END IF
      IF (UPDATE) NUMUPD=NUMUPD+1
!---- LEFT HALF OF UPDATING
      IF (NUMUPD.GT.0) THEN
      DO 438 I=1,NUMUPD
      READ(NBFGS) K,FACT2,VVECT,WVECT
      FACT3=0.D0
      DO 4381 JJ=1,NEQ
4381  FACT3=FACT3+VVECT(JJ)*DR(JJ)
      DO 4382 J=1,NEQ
4382  DR(J)=DR(J)+FACT2*FACT3*WVECT(J)
438   CONTINUE
      END IF
      GO TO 330

!---- MACRO 'JINT'
!---- DOMAIN J-INTEGRAL
   44 CONTINUE
!---- JINT        IAUX        ICRTIP
!----  IAUX = 0 : Usual J-integral is computed
!----  IAUX = 1 : Mode interaction integral (corresponding to Mode I elastic)
!----             field
!----  IAUX = 1 : Mode interaction integral (corresponding to Mode II elastic)
!----             field
!---- ICRTIP = crack tip node number (2-D) for IAUX = 1 or 2; omit if crack
!---- tip is at origin or if IAUX=0.
      LX=LVE(LV)
      L0=LVS(LV)
!     IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.0D0) GO TO 330
!     EMOD2=AMAX1(CT(3,L),1.E0)
!     IF(AMOD(CT(3,LX),EMOD2).NE.0.0E0) GO TO 330
!     END IF
      IAUX = CT(3,L)
      ICRTIP = CT(4,L)
      XCT(1) = 0.D0
      XCT(2) = 0.D0
      IF(ICRTIP.GT.0) THEN
!---- FOLL CARDS ARE ADDED TO COMPUTE INTERACTION J-INTEGRAL FOR
!---- MIXED MODE LOADING
      XCT(1) = X(2*ICRTIP - 1)
      XCT(2) = X(2*ICRTIP) 
      ENDIF
      CALL JINTT(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1 STR,EPS,Q,B,DR,VELG,ACCELG,VEL,ACCEL,CT(2,L),
     2 NDF,NDM,NEN1,NST,NSTR,NQ,NEND,.TRUE.)
      GO TO 330

!---- MACRO 'DDIS'
!---- DUMP DISPLACEMENTS ALL NODES
45    CONTINUE
      LX=LVE(LV)
      L0=LVS(LV)
      IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.0D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.0D0) GO TO 330
      END IF
      DO 451 JNODE = 1,NUMNP
      DO 452 IDIM =1,NDF
      KID=(JNODE-1)*NDF+IDIM
      VARX(IDIM)=B(KID)
452   CONTINUE
      WRITE(LDISP,'(I5,3(1PE13.5))') JNODE,(VARX(IDIM),IDIM=1,NDF)
451   CONTINUE
      GO TO 330

!---- MACRO 'SEFF'
!---- DUMP EFFECTIVE STRESS AND EFFECTIVE PLASTIC STRAIN AT ALL INTG POINTS
46    CONTINUE
      LX=LVE(LV)
      L0=LVS(LV)
      XKEY0 = 4H    
      XKEY1 = 4HSTED
      IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(3,L),1.D0)).NE.0.0D0) GO TO 330
      EMOD2=DMAX1(CT(3,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.0D0) GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY0) THEN
      SIG(5)=0.D0
      SIG(6)=0.D0
!---- EFFECTIVE STRESS
      DO 461 NELM=1,NUMEL
      J=0
      DO 462 INTP=1,NQUAD
      DO 463 I=1,NSDM
      J=J+1
463   SIG(I)=STR(J,NELM)
      SEFFEC(INTP)=SEF(SIG)
462   CONTINUE
      WRITE(LSEFF,'(I5,9(1PE13.5))') NELM,(SEFFEC(IN),IN=1,NQUAD)
461   CONTINUE
!---- EFFECTIVE PLASTIC STRAINS
      DO 464 NELM=1,NUMEL
      DO 465 INTP=1,NQUAD
      J=(INTP-1)*NQDM+3
      SEFFEC(INTP)=Q(J,NELM)
465   CONTINUE
      WRITE(LSEFF,'(I5,9(1PE13.5))') NELM,(SEFFEC(IN),IN=1,NQUAD)
464   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY1) THEN
!---- FOR STEADY STATE CRACK GROWTH WRITE DELTA WP / DELTA X1
!---- IN 'IVAR' FORMAT. THIS WILL BE INCLUDED LATER IN INPUT FILE FOR
!---- 2D HEAT CONDUCTION ROUTINE TO CALCULATE TEMPERATURE FIELDS.
      NDUMMY = 0
      DO 466 NELM=1,NUMEL
      WRITE(LSEFF,'(2I5)') NELM,NDUMMY
      DO 467 INTP=1,NQUAD
      J=(INTP-1)*NQDM+11
      SEFFEC(INTP)=Q(J,NELM)
      WRITE(LSEFF,'(1PE10.3)') SEFFEC(INTP)
467   CONTINUE
466   CONTINUE
      END IF
      GO TO 330

!---- MACRO 'PRTS'
!---- PRINT OUT STRESS, STRAIN, REACTION, DISPLACEMENT OF SAVED ELEMENT
!---- OR NODE SETS
47    CONTINUE
      LX=LVE(LV)
      L0=LVS(LV)
      IF(CT(3,LX).LT.CT(3,L0)) THEN
!     IF(DMOD(CT(3,LX),DMAX1(CT(4,L),1.D0)).NE.0.0D0) GO TO 330
      EMOD2=DMAX1(CT(4,L),1.D0)
      IF(DMOD(CT(3,LX),EMOD2).NE.0.0D0) GO TO 330
      END IF
      XKEY0=4H    
      XKEY1=4HSTRE
      XKEY2=4HSTRA
      XKEY3=4HREAC
      XKEY4=4HDISP
      XKEY5=4HIVAR
      XKEY6=4HCHEC
      XKEY7=4HCONT
      XKEY8=4HJINT
      MSET=CT(3,L)
      IF((MSET.LE.0).OR.(MSET.GT.9)) MSET=1
!---- STRESS PRINT OUT FOR ELEMENT SET MSET
      IF(CT(2,L).EQ.XKEY0) THEN
!---- PRINT OUT STRESS, STRAIN AND INT. VAR. FORM ELMT01 FOR ELEM SET MSET
      CALL PFORMS(MSET,UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,
     1   JDIAG,STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,4,B,
     3   M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY1) THEN
!---- PRINT STRESSES AT CENTER QUADRATURE POINT OF LINEAR ELEMENT SET MSET
      DO 471 II=1,NSET(MSET,1)
      NEL=NSET(MSET,II+1)
      WRITE(LPRTS,'(''STRESS'',1PE13.5,I6,I3,6(1PE13.5))')
     1      TIME,NEL,NQUAD,(STR(I+(NQUAD-1)*NSDM,NEL),I=1,NSDM)
471   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY2) THEN
!---- PRINT STRAINS AT CENTER QUADRATURE POINT OF LINEAR ELEMENT SET MSET
      DO 472 II=1,NSET(MSET,1)
      NEL=NSET(MSET,II+1)
      WRITE(LPRTS,'(''STRAIN'',1PE13.5,I6,I3,6(1PE13.5))')
     1      TIME,NEL,NQUAD,(EPS(I+(NQUAD-1)*NSDM,NEL),I=1,NSDM)
472   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY3) THEN
!---- CALCULATE AND PRINT REACTION OF NODE SET MSET
      CALL PZERO(DR,NEQ)
      CALL PFORM2(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.TRUE.)
      DO 473 II=1,NSET(MSET,1)
      JNODE=NSET(MSET,II+1)
      JNODI=(JNODE-1)*NDF
      WRITE(LPRTS,'(''REAC  '',1PE13.5,I5,3(1PE13.5))')
     1      TIME,JNODE,(-DR(JNODI+NF),NF=1,NDF)
473   CONTINUE
      GO TO 330
      END IF
      IF (CT(2,L).EQ.XKEY4) THEN
!---- PRINT DISPLACEMENT OF NODE SET MSET
      DO 474 II=1,NSET(MSET,1)
      JNODE=NSET(MSET,II+1)
      DO 475 IDIM=1,NDF
      KID=(JNODE-1)*NDF+IDIM
      VARX(IDIM)=B(KID)
475   CONTINUE
      WRITE(LPRTS,' (''DISP  '',1PE13.5,I5,6(1PE13.5))')
     1      TIME,JNODE,X((JNODE-1)*NDM+1),X((JNODE-1)*NDM+2),
     2      (VARX(IDIM),IDIM=1,NDF)
474   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY5) THEN
!---- PRINT INT VARS AT CENTER QUADRATURE POINT OF LINEAR ELEMENT SET MSET
      DO 476 II=1,NSET(MSET,1)
      NEL=NSET(MSET,II+1)
      WRITE(LPRTS,'(''IVAR  '',1PE13.5,I6,I3,6(1PE13.5))')
     1      TIME,NEL,NQUAD,(Q(I+(NQUAD-1)*NQDM,NEL),I=1,4)
!    1                     Q(6+(NQUAD-1)*NQDM,NEL)
476   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY6) THEN
!---- CHECK FOR FAILURE OF ONE OF THE ELEMENTS OF THE SET AND PRINT
!---- NODAL REACTIONS DUE TO STRESSES OF THIS ELEMENT
      CALL PFORMS(MSET,UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,
     1   JDIAG,STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,10,B,
     3   M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY7) THEN 
!---- PRINT TRACTIONS IN CONTACTING SEGMENTS
      IF(NSURF .NE. 0) THEN
      DO 2939 KPA=2,NSURF
      IF((CPSURF(1,KPA) .NE. 0.D0) .OR. (CPSURF(2,KPA) .NE. 0.D0)) THEN
      WRITE(6,2928)
2928  FORMAT(1X,' NODE    CPSURF(X)    CPSURF(Y)')
      GOTO 2940
      ENDIF
2939  CONTINUE
2940  DO 2930 KRJ=2,NSURF
      IF((CPSURF(1,KRJ) .NE. 0.D0) .OR. (CPSURF(2,KRJ) .NE. 0.D0))
     1 WRITE(6,2929)ISURF(KRJ),CPSURF(1,KRJ),CPSURF(2,KRJ)
2929   FORMAT(1X,I5,2(1PE13.5))
2930  CONTINUE
      ENDIF
      IF(NINTND .NE. 0) THEN
      WRITE(6,2927)
2927  FORMAT(1X,' NODE     CPINT(X)     CPINT(Y)')
      DO 478 IPANI=1,NINTND
!     IF((CPSURF(1,IPANI) .NE. 0.0) .OR. (CPSURF(2,IPANI) .NE. 0.0))
      WRITE(6,2929)INTND(1,IPANI),CPINT(1,IPANI),CPINT(2,IPANI)
478   CONTINUE
      END IF
!     IF(NSLAV.EQ.0) GO TO 330
!     CALL CONSTRAC(X,B,NDF)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY8) THEN
!---- CALCULATE J - INTEGRAL CALL SUBROUTINE JLINT
!     **********************************************
      CALL PFORMS(MSET,UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,
     1   JDIAG,STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,10,B,
     3   M(NV),.FALSE.,.FALSE.,.FALSE.,.FALSE.)
      CALL JLINT(NSET(MSET,1),TIME)
      GO TO 330
      END IF

!---- MACRO 'STED'
!---- PERFORMS STEADY STATE CRACK GROWTH
!---- SUGGESTED SET OF MACROS
!     MACR
!     STED         NELROW      NELOUT
!     TOL          1.D-03
!     TANG
!     FORM
!     SOLV
!     CONV
!     LOOP              N
!     CEQS
!     FORM
!     SOLV
!     CONV
!     NEXT
!     REST WRIT

48    CONTINUE
      STEDFL = .TRUE.
      NELROW = CT(3,L)
      NELOUT = CT(4,L)
      IF(NELROW.LE.0) THEN
      WRITE(6,2040) NELROW
      STOP
      END IF

!  PUT DX INTO Q((K-1)*NQDM+10,N) -- ABSOLUTE DISTANCE BETWEEN CURRENT GAUSS
!  POINT K AND THE CORRESPONDING GUY IN THE ELEMENT AHEAD

!  GET X-COORDINATE OF ALL INTEGRATION POINTS OF ALL ELEMENTS
!      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
!    1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
!    2   NDF,NDM,NEN1,NST,NSTR,NQ,8,B,M(NV),.FALSE.,.FALSE.,
!    3   .FALSE.,.FALSE.)
!  COMPUTE DX
!---  LOOP OVER ALL ROWS
!     DO 488 J = 1,INT(NUMEL/NELROW)
!---    LOOP OVER ALL ELEMENTS STARTING FROM LEFT BOUNDARY
!        DO 487 I = 1,NELROW
!           LLLL = J*NELROW - I + 1
!----     LOOP OVER ALL GAUSS POINTS
!           DO 486 K = 1,NQUAD
!              KCUR = (K-1)*NQDM + 10
!----     MAKE SURE THAT FIRST COLUMN OF ELEMENTS HAVE ZERO DX
!              IF (LLLL.EQ.((J-1)*NELROW+1)) THEN
!                 Q(KCUR,LLLL) = 0.
!                 GOTO 485
!              ENDIF
!              Q(KCUR,LLLL) = ABS(Q(KCUR,LLLL-1)-Q(KCUR,LLLL))
485            CONTINUE
!              WRITE(32,'(I6,E13.5)') LLLL,Q(KCUR,LLLL)
486         CONTINUE
487      CONTINUE
488      CONTINUE

      GO TO 330

!---- MACRO 'FSTR'
!---- FINITE STRAIN PLASTICITY WITH RATE CONSTITUTIVE EQUATION (STATIC ANALYSIS)
49    CONTINUE
!     FSTRFL =.TRUE.
!  GET X,Y-COORDINATE OF ALL INTEGRATION POINTS OF ALL ELEMENTS
      ALPHA1 = CT(3,L)
      IF(CT(4,L).GT.0.D0) NSBSTP = CT(4,L)
       CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,8,B,M(NV),.FALSE.,.FALSE.,
     3   .FALSE.,.FALSE.)
      GO TO 330

!---- MACRO 'RNST'
!---- RING-BY-RING STATIC CONDENSATION OF OUTER MESH IN SIMULATION OF
!---- SMALL SCALE YIELDING FRACTURE PROBLEM.
!---- IMPLEMENTED ON AUG 25, 1992
!---- NOTE IN THE PRESENT VERSION THE ENTIRE (UPPER AND LOWER) X-Y PLANE
!---- SHOULD BE CONSIDERED. SYMMETRY ABOUT CRACK PLANE NOT CONSIDERED.
!---- NELGAM IS # ELEMS IN EACH OUTER RING. NRING IS # OF OUTER RINGS TO
!---- BE CONDENSED OUT. THE MACRO IS GIVEN AS FOLL:
!---- RNST         NELGAM        NRING
51    CONTINUE
      NELGAM = CT(3,L)
      NRING  = CT(4,L)
      IF((NELGAM.LE.0).OR.(NRING.LE.0)) THEN
      WRITE(6,2041) NELGAM,NRING
      STOP
      END IF
      RNSTFL = .TRUE.
      NGAMA = NELGAM + 1
      N2GAMA = NGAMA*2
      N4GAMA = N2GAMA*2
      NBAND1 = N2GAMA + 4
      NMRC1 = NE
      NMRC2 = NMRC1 + N4GAMA*NBAND1*IPR
      NMRC3 = NMRC2 + N4GAMA*IPR
      NMRC4 = NMRC3 + N4GAMA*NBAND1*IPR
      NE = NMRC4 + N4GAMA*IPR
      CALL SETMEM(NE)
      CALL RNSTCN(UL,XL,TL,P,S,D,X,F,STR,EPS,Q,VEL,ACCEL,M(NMRC1),
     1 M(NMRC2),M(NMRC3),M(NMRC4),NDF,NDM,NST,NSTR,NQ,NELGAM,NGAMA,
     2 N2GAMA,N4GAMA,NRING,NBAND1)
      GO TO 330

!---- MACRO 'SMTH'
!---- MACRO FOR SMOOTHING ELEM STRESSES AND INTERNAL VARIABLES
!---- SUGGESTED MACRO COMMANDS
!     MACR
!     RESF READ
!     TANG
!     SMTH MESH
!     SMTH STRE          1         2
!     SMTH STRE          3         4
!     SMTH IVAR          2         3
!     SMTH IVAR          4         5
!     SMTH REZO
!     END
!     STOP
52    CONTINUE
      XKEY0=4H    
      XKEY1=4HMESH
      XKEY2=4HREZO
      XKEY3=4HSTRE
      XKEY4=4HIVAR
      XKEY5=4HDISP
      XKEY6=4HSTRA
      IF(CT(2,L).EQ.XKEY0) THEN
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY1) THEN
      REWIND LSMTH
      CALL SMTWRT(X,B,IX,DR,STR,Q,NUMNP,NUMEL,NEN1,NDM,NDF,NSTR,
     1 NQ,1)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY5) THEN
!---- INITIALIZE DISPLACEMENT ARRAY TO ZERO
      DO 521 I=1,NEQ
      B(I) = 0.D0
521   CONTINUE
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY2) THEN
      CALL SMTWRT(X,B,IX,DR,STR,Q,NUMNP,NUMEL,NEN1,NDM,NDF,NSTR,
     1 NQ,3)
      GO TO 330
      END IF
      IF(CT(2,L).EQ.XKEY3) THEN
      D(1) = CT(3,L)
      D(2) = CT(4,L)
      END IF
      IF(CT(2,L).EQ.XKEY4) THEN
      D(1) = 0.D0
      D(2) = 0.D0
      IF(CT(3,L).GT.0.D0) D(1) = 4.D0 + CT(3,L)
      IF(CT(4,L).GT.0.D0) D(2) = 4.D0 + CT(4,L)
      END IF
      IF(CT(2,L).EQ.XKEY6) THEN
      D(1) = 0.D0
      D(2) = 0.D0
      IF(CT(3,L).GT.0.D0) D(1) = 13.D0 + CT(3,L)
      IF(CT(4,L).GT.0.D0) D(2) = 13.D0 + CT(4,L)
      END IF
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,6,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
      IF(GFL) THEN
      WRITE(6,'(///'' **ERROR** DETECTED BY MACRO SMTH ''
     1 /'' ATTEMPT TO SMOOTH ELEMENT STRESSES AND INT VARIABLES''
     2 /'' BEFORE FORMING STIFF MATRIX'')')
      STOP 
      END IF 
      CALL ACTCOL(M(NA),DR,JDIAG,NEQ,AFR,.TRUE.)
      AFR=.FALSE.
      CALL SMTWRT(X,B,IX,DR,STR,Q,NUMNP,NUMEL,NEN1,NDM,NDF,NSTR,
     1 NQ,2)
      GO TO 330

!---- MACRO 'RITZ' 
!---- MACRO FOR PERFORMING COMBINED FEA-RAYLEIGH RITZ ANALYSIS TO CONTROL NODAL 
!     INSTABILITIES. NOTE: YOU CAN MAKE USE OF ONLY 1 TIME VARYING EXTERNAL
1     FORCE OR DISPLACEMENT QUANTITY TO APPLY EXTERNAL LOAD
53    CONTINUE
!---- SUGGESTED MACROS
!---- MACR
!     DT              VAL
!     REST READ
!     FORM PRIN
!     LOOP              N
!     TIME
!     TANG
!     RITZ                       DELPROP
!     CEQS
!     FORM PRIN
!     NEXT
!     END
!     STOP
!---- THE NODE NUMBERS WHOSE DISPLACEMENT DOFS ARE TO BE CONTROLLED ARE INPUT VIA
!---- SET MACRO: USE SET #1 FOR PRESCRIBING THESE NODES.
!
!---- IF YOU WANT TO CONTROL THE RITZ VARIABLE # MRVAR BY PRESCRIBING ITS
!---- INCREMENT IN DISPL AS DELPROP THEN USE FOLL MACRO
!     RITZ MANU      MRVAR       DELPROP

!---- IF YOU WANT TO HAVE AUTO CONTROL OF RITZ VARIABLES USE FOLL MACRO
!     RITZ AUTO      MRVAR       DELPROP
!---- NOTE: FOR 1st TIME STEP YOU HAVE TO SPECIFY THE VARIABLE TO BE
!---- BE CONTROLLED AND ITS INCREMENT. AUTO CONTROL WILL TAKE OVER FROM
!---- 2nd TIME STEP ONWARDS.

!---- TO INVOKE SPECIAL CONTROL OF NODAL DISPLS OF INTERFACE NODES IN INTERFACE
!---- MODELLING, USE FOLL MACRO:
!     RITZ COHS      DELLOAD     DELLAMDA
!---- NOTE: FIRST RUN A LOAD STEP IN THE USUAL WAY AND WRITE A RESTART FILE.
!----       THEN, MAKE A RESTART RUN AND USE THE ABOVE MACRO
!---- NOTE: FOR ABOVE RUN, SET #1 WILL BE UTILISED FOR THE PAIR OF INTERFACE
!----       NODES TO BE STABILIZED BASED ON WHICH PAIR HAS HIGHEST LAMDA.
!----       IF LAMDA THUS DETERMINED IS > VALUE REQD FOR SOFTENING TO
!----       START IN THE INTERFACE MODEL, INCREMENTS IN DELLAMDA (CT(4,L))
!----       WILL BE GIVEN. OTHERWISE, INCREMENT IN LOAD (CT(3,L)) WILL BE
!----       GIVEN.

!     MSET = CT(3,L)
      IF(TIME.LE.DT) THEN
      PROP(1) = 0.D0
      PROP(2) = 0.D0
      PROP(3) = 0.D0
      END IF
      MSET = 1
      XKEY0=4H    
      XKEY1=4HMANU
      XKEY2=4HAUTO
      XKEY3=4HCOHS
      IF(CT(2,L).NE.XKEY3) THEN
      MRVAR = CT(3,L)
      END IF
      DELPROP = CT(4,L)
      IF(CT(2,L).EQ.XKEY3) THEN
      CALL RITZSB8(B,PROP,NDF,IRTMAX,MRVAR,DELPROP)
      IF(MRVAR.EQ.0) THEN
      IF(PROP(1).LT.PROP(2)) THEN
      DELPROP = (PROP(2)-PROP(3))/50.D0
      ELSE
      DELPROP = CT(3,L)
      END IF
      ELSE
      DELPROP = DELPROP*CT(4,L)
      END IF
      END IF
      IF(MSET.EQ.0) THEN
      WRITE(6,2044)
      STOP
      END IF
      MRITZ1 = NSET(MSET,1)
      IF(MRITZ1.EQ.0) THEN
      WRITE(6,2045)
      STOP
      END IF
      MRITZ = NDF*MRITZ1
      MRITZ2 = MRITZ + 2
!---- SET UP STORAGE FOR ALL REQD ARRAYS
      IF(HFL) THEN
      NR1 = NE
      NR2 = NR1 + JDIAG(NEQ)*IPR
      NR3 = NR2 + (MRITZ+2)*NEQ*IPR
      NR4 = NR3 + (MRITZ+2)*(MRITZ+2)*IPR
      NR5 = NR4 + (MRITZ+2)*IPR
      NR6 = NR5 + (MRITZ+2)*IPR
      NE = NR6 + (MRITZ+3)*IPR
      CALL SETMEM(NE)
!     HFL = .FALSE.
!---- WRITE OUT INFORM READ
      WRITE(6,2046) MRITZ,DELPROP
      IF(CT(2,L).EQ.XKEY1) THEN
      WRITE(6,2047) MRVAR
      END IF
      IF(CT(2,L).EQ.XKEY2) THEN
      WRITE(6,2048) MRVAR
      END IF
      END IF
!---- FORM RHS VECTOR ASSUMING DELPROP=1 (UNIT INCR IN EXT FORCE OR DISPL PARAMETER)
      PROPOL(1) = PROP(1)
      IF(TIME.LE.DT) PROPOL(1) = 0.D0
      PROP(1) = 1.D0
      CALL PZERO(DR,NEQ)
!---- LOAD EXTERNALLY PRESCRIBED FORCE RATE CORR TO UNIT INCRMENT IN LOAD
!---- QTY INTO DR ARRAY
      CALL PLOAD(ID,IX,PDIST,IDIST,F,DR,NEQ,IDPROP,PROP,NEN,NEN1,NDF,
     1 NST,NDIST)
      PROP(1) = PROPOL(1) + 1.D0
!---- IF YOU HAVE SPECIFIED DISPLS, TAKE CARE TO MODIFY DR ARRAY. AGAIN,
!---- IF THERE IS NON-HOMOG PRESCRIBED DISPLS, GET CONTRBNS DUE TO UNIT
!---- INCREMENT IN PRESCRIBED DISPL QTY INTO DR ARRAY
!---- IMPORTANT *****: MAKE SURE ISW = 2 IS UNUSED BY YOUR ELMT01
      CALL PFORM(UL,XL,TL,LD,P,S,IE,D,ID,X,IX,IDPROP,PROP,F,T,JDIAG,
     1   STR,EPS,Q,DR,DR,DR,VELG,ACCELG,VEL,ACCEL,
     2   NDF,NDM,NEN1,NST,NSTR,NQ,2,B,
     3   M(NV),.FALSE.,.TRUE.,.FALSE.,.FALSE.)
!---- IF EQBM WAS IDENTICALLY SATISFIED IN LAST TIME STEP REMOVE OLDFRC
!     OLDFNRM = DOT(OLDFRC,OLDFRC,NEQ)
!     IF(OLDFNRM.LT.1.0E-06) MRITZ2 = MRITZ2 - 1
      IF((RN1.LE.(TOL*RN)).OR.(RN.EQ.0.D0)) MRITZ2 = MRITZ2 - 1
!---- NOTE FOR DOUBLE PRECISION: YOU SHOULD USE 1.0E-14 IN ABOVE STATEMENT
!---- STEP 1: RE-ORDER [K] MATRIX AND FORM MODIFIED RHS VECTORS
      CALL RITZSB1(M(NA),DR,OLDFRC,M(NR1),M(NR2),JDIAG,NEQ,NDF,
     1 MRITZ,MSET)
!---- STEP 2: COMPUTE RITZ VECTORS
      CALL RITZSB2(M(NR1),M(NR2),JDIAG,NEQ,MRITZ2)
!---- STEP 3: FORM REDUCED STIFF MATRIX AND RHS VECTORS
      CALL RITZSB3(M(NA),DR,OLDFRC,DELFRC,M(NR2),JDIAG,M(NR3),M(NR4),
     1 M(NR5),NEQ,MRITZ,MRITZ2)
!---- STEP 4: SOLVE REDUCED SYSTEM OF EQNS AND GET DELDOT

      IF((CT(2,L).EQ.XKEY0).OR.(MRVAR.EQ.0)) THEN
!---- NO SPECIAL CONTROL SOUGHT OVER ANY OF THE RITZ VARIABLES
!---- SO, INCREMENT LOAD BY DELPROP
      CALL RITZSB4(M(NR3),M(NR4),M(NR5),M(NR6),DELPROP,MRITZ,
     1 MRITZ2,MRVAR,.FALSE.)
      END IF

      IF(CT(2,L).EQ.XKEY1) THEN
!---- MANUAL CONTROL IS SOUGHT OVER THE RITZ VARIABLE MRVAR 
      CALL RITZSB4(M(NR3),M(NR4),M(NR5),M(NR6),DELPROP,MRITZ, 
     1 MRITZ2,MRVAR,.TRUE.)
      END IF

      IF(CT(2,L).EQ.XKEY2) THEN
!---- AUTO CONTROL SOUGHT OVER RITZ VARIABLES
      IF(.NOT.HFL) THEN
!---- SUBSEQUENT TIME STEPS OF A RUN. DETERMINE WHICH VARIABLE IS TO
!---- STABILIZED AND INCREMENT SIZE BASED ON PREVIOUS TIME STEP.
!---- FOR FIRST TIME STEP GO WITH WHAT USER HAS SPECIFIED IN CT(3,L)
!---- AND CT(4,L).
      CALL RITZSB6(B,M(NR6),NDF,MSET,MRITZ,MRVAR,DELPROP)
      WRITE(6,2049) TIME,MRVAR,DELPROP
      END IF
      CALL RITZSB4(M(NR3),M(NR4),M(NR5),M(NR6),DELPROP,MRITZ, 
     1 MRITZ2,MRVAR,.TRUE.)
      END IF

      IF((CT(2,L).EQ.XKEY3).AND.(MRVAR.NE.0)) THEN
!---- SPECIAL AUTO CONTROL OF RITZ VARIABLES FOR INTERFACE MODELLING
      CALL RITZSB7(M(NR3),M(NR4),M(NR5),M(NR6),B,ID,DELPROP,NDF,
     1 MRITZ,MRITZ2,IRTMAX)
      END IF
!---- RECONSTRUCT GLOBAL NODAL DISPL INCREMENT 
      CALL RITZSB5(DR,OLDFRC,M(NR2),M(NR6),PROP,PROPOL,MRITZ,MRITZ2,
     1 NEQ)
!---- UPDATE GLOBAL NODAL DISPL VECTOR JUST LIKE YOU WOULD IN MACRO SOLVE
      RN = 0.D0
      DO 532 I=1,NEQ
      IF(ID(I).EQ.0) THEN
      RN=RN+OLDFRC(I)*OLDFRC(I)
      END IF
532   CONTINUE
      RN=DSQRT(RN)
      ENRG = DOT(DR,OLDRFC,NEQ)
!     IF(NINTND.GT.0)
!    1 CALL FORCINT(DR,X,B,NDF,NDM)
      DO 531 I=1,NEQ
531   B(I)=B(I)+DR(I)
      HFL = .FALSE.

      GO TO 330 
330   L = L + 1
      IF (L.LE.LL) GO TO 299
      WRITE(6,2008)
      PRT=.FALSE.
      IF(TMAX.GT.0.D0) THEN
      IF(TIME.LT.TMAX1) THEN
      WRITE(6,2023)
      RETURN
      END IF
      END IF
      WRITE(6,2024)
      RETURN
400   WRITE(6,4000)
      PRT = .FALSE.
      RETURN
401   WRITE(6,4001)
      PRT = .FALSE.
      RETURN
402   WRITE(6,4002)
      PRT = .FALSE.
      RETURN
403   WRITE(6,4003)
      PRT = .FALSE.
      RETURN
404   WRITE(6,4004)
      PRT = .FALSE.
      RETURN
!---- THE FOLLOWING SEGMENT HAS BEEN ADDED BY R.NARASIMHAN ON JAN 25, 1987
405   CONTINUE
      WRITE(6,2015)
      STOP
406   CONTINUE
      L0=LVE(LV)
      LX=LVS(LV)
      LX1=LX+1
      XKEY0=4H    
      XKEY1=4HCONV
      XKEY2=4HAUTO
414   CONTINUE
      IF((CT(1,LX1).EQ.XKEY1).AND.(CT(2,LX1).EQ.XKEY2)) GO TO 411
      LX1=LX1+1
      IF(LX1.LT.L0) GO TO 414
      WRITE(6,2016)
      STOP
411   CONTINUE
      NCONV=0
      DTMIN=CT(3,LX1)
      DTMAX=CT(4,LX1)
      DTNEW=DT/4.D0
      IF(DTNEW.LT.DTMIN) THEN
      WRITE(6,2016)
      STOP
      END IF
      TIME=TIMOLD+DTNEW
      IF(TMAX.GT.0.D0) THEN
      IF(TIME.GE.TMAX1) THEN
      TIME=TMAX
      END IF
      END IF
      DT=DTNEW
      WRITE(6,2026) DT
      NATMPT=NATMPT+1
      L=LX-1
      LV=LV-1
      GO TO 330
407   CONTINUE
!---- DIVERGENCE HAS BEEN DETECTED IN NEWTON ITERATION.
!---- AUTO STEPPING IS REQUESTED. CUT TIME STEP AND ATTEMPT ITERATION LOOP AGAIN
      NCONV=0
      DTNEW=DT/4.D0
      IF(DTNEW.LT.DTMIN) THEN
      WRITE(6,2015)
      STOP
      END IF
!     TIME=TIME-DT+DTNEW
      TIME=TIMOLD+DTNEW
      IF(TMAX.GT.0.D0) THEN
      IF(TIME.GE.TMAX1) THEN
      TIME=TMAX
      END IF
      END IF
      DT=DTNEW
      WRITE(6,2018) DT
      NATMPT=NATMPT+1
!---- FIND LOOP STATEMENT OF ITERATION LOOP
      XKEY0=4H    
      XKEY1=4HITRN
408   LX=LVS(LV)
      IF(CT(2,LX).EQ.XKEY1) GO TO 409
      LV=LV-1
      IF(LV.GT.1) GO TO 408
      WRITE(6,2019)
      STOP
409   CONTINUE
!---- START OF ITERATION LOOP HAS BEEN FOUND. TRANSFER CONTROL.
      L=LX-1
      LV=LV-1
      GO TO 330
410   CONTINUE
!---- HEALTHY CONVERGENCE TREND. SINCE AUTO STEPPING HAS BEEN REQUESTED,
!---- INCREASE TIME STEP SIZE.
      NCONV=0
      IF(DT.GE.DTMAX) GO TO 330
      DTNEW=DT*1.5
      IF(DTNEW.GT.DTMAX) DTNEW=DTMAX
      DT=DTNEW
      WRITE(6,2020) DT
      GO TO 330
416   CONTINUE
!---- PLASTIC DISSIPATION OR TOO LARGE PLASTIC STRAIN INCREMENTS.
!---- IF AUTO-STEPPING HAS BEEN REQUESTED, DECREASE TIME STEP SIZE
!---- AND TRY AGAIN.
!---- LOCATE START OF ITERATION LOOP
      LV=0
      XKEY0=4H    
      XKEY1=4HITRN
4161  LV=LV+1
      LX=LVS(LV)
      L0=LVE(LV)
      IF(CT(2,LX).EQ.XKEY1) GO TO 4162
      IF(LV.LT.9) GO TO 4161
      WRITE(6,2032)
      STOP
4162  CONTINUE
!---- START OF ITERATION LOOP HAS BEEN LOCATED.
!---- NOW CHECK IF AUTO-STEPPING HAS BEEN REQUESTED
      LX1=LX+1
      XKEY0=4H    
      XKEY1=4HCONV
      XKEY2=4HAUTO
4163  CONTINUE
      IF((CT(1,LX1).EQ.XKEY1).AND.(CT(2,LX1).EQ.XKEY2)) GO TO 4164
      LX1=LX1+1
      IF(LX1.LT.L0) GO TO 4163
      WRITE(6,2032)
      STOP
4164  CONTINUE
      NCONV=0
      DTMIN=CT(3,LX1)
      DTMAX=CT(4,LX1)
      DTNEW=DT/4.D0
      IF(DTNEW.LT.DTMIN) THEN
      WRITE(6,2032)
      STOP
      END IF
      TIME=TIMOLD+DTNEW
      IF(TMAX.GT.0.D0) THEN
      IF(TIME.GE.TMAX) THEN
      TIME=TMAX
      END IF
      END IF
      DT=DTNEW
      WRITE(6,2033) DT
      NATMPT=NATMPT+1
      L=LX-1
      LV=LV-1
      GO TO 330
 1000 FORMAT(A4,1X,A4,1X,2F10.0)
2000  FORMAT(10X,A4,1X,A4,1X,2G15.5)
2001  FORMAT(A1,20A4//5X,18HMACRO INSTRUCTIONS//5X,15HMACRO STATEMENT,5X
     1,10HVARIABLE 1,5X,10HVARIABLE 2)
2002  FORMAT(5X,29HDISPLACEMENT CONVERGENCE TEST/10X,7HUNMAX =,G15.5,5X,
     1   7HUN    =,G15.5,5X,7HTOL   =,G15.5)
2004  FORMAT(5X,4HCN =,G12.5,5X,4HDN =,G12.5,5X,4HUN =,G12.5,5X,4HAG =
     1   ,G12.5,5X,4HAC =,G12.5)
2005  FORMAT(5X,22HFORCE CONVERGENCE TEST/10X,7HRNMAX =,G15.5,5X,
     1   7HRN    =,G15.5,5X,7HTOL   =,G15.5)
2006  FORMAT(5X,'DISPLACEMENT CONVERGENCE TEST'/10X,7HRNMAX =,G15.5,5X,
     1   7HRN    =,G15.5,5X,7HTOL   =,G15.5)
2008  FORMAT('  **END OF MACRO EXECUTION**')
2010  FORMAT(2X,19H**MACRO INSTRUCTION,I4,3H **  ,2(A4,2X),
     1   3HV1= ,G11.4, 5H ,V2= ,G11.4)
2011  FORMAT(2X,'**STOP ITERATION, REQUIRED ACCURACY NOT ACHIEVED**')
2012  FORMAT(//2X,'INITIAL FORCE NORM=',E15.7,3X,
     1 'INITIAL INTERNAL ENERGY=',E15.7)
2014  FORMAT(//2X,'CURRENT FORCE NORM=',E15.7,3X,
     1 'CURRENT INTERNAL ENERGY=',E15.7)
2015  FORMAT(//5X,'*** DIVERGENCE DETECTED IN NEWTON ITERATION ***'
     1 /5X,'*** EXECUTION TERMINATED. REDUCE TIME INCREMENT SIZE ***')
2016  FORMAT(//5X,'*** CONVERGENCE NOT ATTAINED IN NEWTON ITERATION'
     1 /5X,'*** EXECUTION TERMINATED. REQUIRE MORE # OF ITERATIONS')
2017  FORMAT(//2X,'*** RESTART INFORMATION WRITTEN AT TIME',
     1 E13.5,' AFTER TIME INCREMENT#=', F6.1)
2018  FORMAT(//5X,'*** DIVERGENCE DETECTED IN NEWTON ITERATION ***'
     1 /5X,'*** REDUCING TIME INCREMENT SIZE TO DT=',E15.7)
2019  FORMAT(//5X,'*** CANNOT FIND START OF ITERATION LOOP ***'
     1 /5X,'*** EXECUTION TERMINATED. SPECIFY START OF ITERATION',
     2 ' LOOP')
2020  FORMAT(//5X,'*** BASED ON CONVERGENCE OF LAST THREE TIME STEPS',
     1 /5X,'*** THE NEW TIME INCREMENT SIZE DT=',E15.7)
2021  FORMAT(//5X,'TIME INCREMENT #=',F6.1,5X,'ATTEMPT #=',I5/
     1         5X,'DT=',E15.7,5X,'TIME=',E15.7)
2022  FORMAT(//5X,'PERFORMING UPDATE OF TANGENT STIFFNESS MATRIX')
2023  FORMAT(//5X,'*** WARNING: ANALYSIS HAS NOT BEEN COMPLETED'/
     1         5X,'SPECIFIED MAXIMUM TIME HAS NOT BEEN ATTAINED')
2024  FORMAT(//5X,'*** ANALYSIS HAS BEEN COMPLETED')
2026  FORMAT(//5X,'*** CONVERGENCE NOT ATTAINED IN NEWTON ITERATION'/
     1         5X,'*** REDUCING TIME INCREMENT SIZE TO DT=',E15.7)
2027  FORMAT(//5X,'*** LINE SEARCH UNSUCCESSFUL',/
     1         5X,'STEP=',E13.5,5X,'GSTEP=',E13.5)
2028  FORMAT(//5X,'*** PARAMETERS COMPUTED BY LINE SEARCH',/
     1 5X,'STEP=',E13.5,5X,'GSTEP=',E13.5,5X,'GTOL=',E13.5,5X,'LIN=',
     2 I4)
2029  FORMAT(//5X,'*** LINE SEARCH FOUND UNNECESSARY',/
     1 5X,'STEP=',E13.5,5X,'GSTEP=',E13.5,5X,'GTOL=',E13.5)
2030  FORMAT(//5X,'** FATAL ERROR ** ATTEMPT TO INPUT',I6,' PROP',
     1 ' TABLES. TERMINATION OCCURED IN MACRO PROP')
2031  FORMAT(//5X,'*** PERFORMING BFGS UPDATE',I5)
2032  FORMAT(//5X,'*** EXECUTION TERMINATED. REDUCE TIME STEP SIZE')
2033  FORMAT(//5X,'*** REDUCING TIME INCREMENT SIZE TO DT=',E15.7)
2034  FORMAT(//2X,'*** RESTART INFORMATION READ AT TIME',
     1 E13.5)
2035  FORMAT(//2X,'***PROP LOAD VALUES ARE',/,7F10.2)
2039  FORMAT(' NUMBER EIGENVALUES REDUCED TO',I4,' BY NUMBER OF NONZERO
     1LUMPED MASS TERMS')
2040  FORMAT(//5X,'** FATAL ERROR:',/,'NUMBER OF ELEMS PER ROW FOR',
     1 ' STEADY STATE CRACK GROWTH',I7,' IS LESS THAN OR EQUAL TO ZER0')
2041  FORMAT(//5X,'** FATAL ERROR:',/,'NUMBER OF ELEMS IN RING OR',
     1 ' NUMBER OF RINGS IN MACRO RNST IS NOT +VE',2I5)
2042  FORMAT(//5x,'** FATAL ERROR:',/,'MASS MATRIX NOT FORMED',  
     1 ' BEFORE STIFF MATRIX WHILE DOING NEWMARK INTGRN')
2043  FORMAT(//5X,'** FATAL ERROR:',/,'NEWMARK PARAMS NOT DEFINED',
     1 ' BEFORE FORMING STIFF MX')
2044  FORMAT(5X,'FATAL ERROR: NODE SET NO. FOR RITZ INSTABILITY',
     1 ' CONTROL NOTSPECIFIED')
2045  FORMAT(5X,'FATAL ERROR: SET OF NODES FOR RITZ INSTABILITY',
     1 ' CONTROL NOT INPUT VIA SET MACRO')
2046  FORMAT(5X,'****NUMBER OF RITZ VARIABLES       =',I5,/,
     1 5X,'INCREMENT IN LOAD OR DISPL OR A RITZ VARIABLE=',E13.5)
2047  FORMAT(5X,'MANUAL CONTROL REQUESTED FOR RITZ VARIABLE =',I5)
2048  FORMAT(5X,'AUTO CONTROL OF RITZ VARIABLES REQUESTED',/,
     1          'FOR FIRST TIME STEP CONTROL VARIABLE #=',I5)
2049  FORMAT(5X,'**** AUTO CONTROL OF RITZ VARIABLES ****',/,
     1 5X,'TIME =',E13.5,2X,'RITZ VARIABLE #=',I5,2X,'INCREMENT =',
     2 E13.5)
4000  FORMAT(5X,46H**FATAL ERROR 10** UNBALANCED LOOP/NEXT MACROS )
4001  FORMAT(5X,45H**FATAL ERROR 11** LOOPS NESTED DEEPER THAN 8)
4002  FORMAT(5X,57H**FATAL ERROR 12** MACRO LABEL MISMATCH ON A READ COM
     1MAND)
4003  FORMAT(5X,63H**FATAL ERROR 13** MACRO EXCD MUST BE PRECEDED BY LMA
     1S AND FORM)
4004  FORMAT(5X,84H**FATAL ERROR 14** ATTEMPT TO CHANGE BOUNDARY RESTRAI
     1NT CODES DURING MACRO EXECUTION )
      END

      SUBROUTINE CNDMAS(A,B,JDIAG,NEQ,IOP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

!---- SETS UP DUMMY DIAGONAL MASS MATRIX FOR COMPUTING
!---- EIGENVALUES OF SCALED K MATRIX (IOP = 1) OR
!---- EIGENVALUES OF UNSCALED K MATRIX (IOP.NE.1)
!---- 'A' IS STIFFNESS MATRIX AND 'B' IS MASS MATRIX

      DIMENSION A(*),B(*),JDIAG(*)
      DO 10 I=1,NEQ
      JJ = JDIAG(I)
      IF(IOP.EQ.1) B(I) = A(JJ)
      IF(IOP.NE.1) B(I) = 1.D0
10    CONTINUE
      RETURN
      END

      SUBROUTINE NEWMST(A,B,ID,DR,ACCELG,JDIAG,NEQ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

!----  MODIFIES STIFFNESS MATRIX, & FORCE VECTOR BY ADDING CONTRBN FROM
!----  MASS MATRIX WHEN DOING NEWMARK -BETA, GAMMA INTEGRN
!---- 'A' IS STIFFNESS MATRIX AND 'B' IS LUMPED MASS MATRIX

      DIMENSION A(*),B(*),ID(*),JDIAG(*),DR(*),ACCELG(*)
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      DO 10 I=1,NEQ
      IF(ID(I).EQ.0) THEN
      JJ = JDIAG(I)
      A(JJ) = A(JJ) + B(I)/(DT*DT*BETA)
      DR(I) = DR(I) - B(I)*ACCELG(I)
      END IF
10    CONTINUE
      RETURN
      END

      SUBROUTINE TRNSEG(V,ID,B,NEQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

!---- TRANSFERS EIGEN VECTOR CALCULATED BY SUBSPACE ITERATION TO VECTOR B

      DIMENSION ID(*),V(NEQ,*),B(*)
      DO 100 I=1,NEQ
      IF(ID(I).EQ.0) THEN
      B(I) = V(I,1)
      ELSE
      B(I) = 0.D0
      END IF
100   CONTINUE
      RETURN
      END

      SUBROUTINE SMTWRT(X,B,IX,DR,STR,Q,NUMNP,NUMEL,NEN1,NDM,NDF,
     1 NSTR,NQ,IOPT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /TAPE/ NMAT,NRED,NPVT,NELSTF,NBFGS,LDUMP,LREST,LSEFF,
     1 LDISP,LPRTS,LRESF,LSMTH
      DIMENSION X(NDM,*),B(NDF,*),IX(NEN1,*),DR(NDF,*),STR(NSTR,*),
     1 Q(NQ,*)
      N1=NDM*NUMNP
      N2=NDF*NUMNP
      GO TO (10,20,30)IOPT
10    CONTINUE
      IF(NDF.EQ.2) THEN
      WRITE(LSMTH) (X(1,I),X(2,I),B(1,I),B(2,I),I=1,NUMNP),
     1 ((IX(I,J),I=1,4),J=1,NUMEL)
      END IF
      IF(NDF.EQ.1) THEN
      WRITE(LSMTH) (X(1,I),X(2,I),B(1,I),I=1,NUMNP),
     1 ((IX(I,J),I=1,4),J=1,NUMEL)
      END IF
      RETURN
20    CONTINUE
      WRITE(LSMTH) (DR(1,I),I=1,NUMNP)
      IF(NDF.EQ.2)
     1  WRITE(LSMTH) (DR(2,I),I=1,NUMNP)
      RETURN
30    CONTINUE
      DO 35 J=1,NUMEL
      WRITE(LSMTH) (STR(I,J),I=1,NSTR),(Q(I,J),I=1,NQ)
35    CONTINUE
      RETURN
      END

      SUBROUTINE RITZSB1(A,F,R,AP,RI,JDIAG,NEQ,NDF,MR,MSET)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- MODIFY [K] MATRIX AND FORM MODIFIED RHS VECTORS
      DIMENSION A(*),F(*),R(*),AP(*),RI(NEQ,*),JDIAG(*)
      COMMON /PRTSET/ NSET(9,201)
      MR1 = MR/NDF
!---- FIRST TRANSFER A TO AP
      DO 5 I = 1,JDIAG(NEQ)
      AP(I) = A(I)
5     CONTINUE
!---- TRANSFER F AND R TO (MR+1) AND (MR+2) RHS VECTORS
      DO 6 I =1,NEQ
      RI(I,MR+1) = F(I)
      RI(I,MR+2) = R(I)
6     CONTINUE
!---- LOOP OVER ALL NODES WHOSE NODAL DISPLS HAVE TO BE CONTROLLED
!---- FORM THE RHS VECTORS CORRESP TO 1 TO MR BY TAKING THE -VE OF THE
!---- CORRESP COLS OF K MATRIX
!---- ALSO INSERT ZEROES IN APPROPRIATE COLS (AND 1 ON DIAGS) OF AP
      DO 10 I=1,MR1
      N = NSET(MSET,I+1)
      DO 15 J=1,NDF
      IJ = (I-1)*NDF + J
!---- IJ IS THE RHS VECTOR WHICH IS BEING FORMED
      NJ = (N-1)*NDF + J
!---- NJ IS COL NUMBER OF [K] WHICH WILL BE USED TO FORM THE ABOVE RHS VECTOR
!---- FIRST TREAT TERMS ON AND ABOVE THE DIAGONAL OF COLUMN NJ OF STIFF MATRIX
      IF(NJ.EQ.1) THEN
      NJ1D = 0
      ELSE
      NJ1D = JDIAG(NJ-1)
      END IF
      DO 20 K=1,NJ
      KNJ = JDIAG(NJ) - NJ + K
      IF(KNJ.LE.NJ1D) THEN
!---- THE TERM (K,NJ) IS OUTSIDE THE PROFILE OF [K] AND IS ALREADY ZERO
      RI(K,IJ) = 0.D0
      ELSE
      RI(K,IJ) = -A(KNJ)
!---- PUT ZERO IN THE CORRESP TERM OF AP (IF IT IS OFF-DIAG) AND UNITY IF
!---- ON DIAGONAL
      AP(KNJ) = 0.D0
      IF(K.EQ.NJ) AP(KNJ) = 1.D0
      END IF
20    CONTINUE
!---- NOW FOR TERMS BELOW THE DIAGONAL OF COLUMN NJ OF STIFF MATRIX
      DO 25 K=NJ+1,NEQ
!---- SINCE MATRIX IS SYMM K(K,NJ) = K(NJ,K) = A(JDIAG(K)-K+NJ)
      NJK = JDIAG(K) - K + NJ
      IF(NJK.LE.JDIAG(K-1)) THEN
!---- THE TERM (NJ,K) IS OUTSIDE THE PROFILE OF [K] AND IS ALREADY ZERO
      RI(K,IJ) = 0.D0
      ELSE
      RI(K,IJ) = -A(NJK)
!---- ZERO THE CORRESP TERM OF AP
      AP(NJK) = 0.D0
      END IF
25    CONTINUE
15    CONTINUE
10    CONTINUE
!---- FINALLY INSERT ZEROES IN APPROPRIATE ROWS OF ALL RHS VECTORS 
      DO 30 I=1,MR1
      N = NSET(MSET,I+1)
      DO 35 J=1,NDF
      IJ = (I-1)*NDF + J
      NJ = (N-1)*NDF + J
!---- NJ IS ROW OF RHS VECTORS CORRESP TO THE VARIABLE IJ WHICH IS BEING STABILIZED
!---- LOOP OVER ALL (1 TO MR) RHS VECTORS
      DO 40 K=1,MR
      IF(K.NE.IJ) THEN
      RI(NJ,K) = 0.D0
      ELSE
      RI(NJ,K) = 1.D0
      END IF
40    CONTINUE
      RI(NJ,MR+1) = 0.D0
      RI(NJ,MR+2) = 0.D0
35    CONTINUE
30    CONTINUE
      RETURN
      END

      SUBROUTINE RITZSB2(AP,RI,JDIAG,NEQ,MR2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- COMPUTE RITZ VECTORS
!---- NOTE MR2 = MRITZ+2. IF OLDFRC = 0, MR2 = MRITZ + 1

      LOGICAL AFR,BFR
      DIMENSION AP(*),RI(NEQ,*),JDIAG(*)
      AFR = .TRUE.
      BFR = .TRUE. 
      DO 10 I=1,MR2
      CALL ACTCOL(AP,RI(1,I),JDIAG,NEQ,AFR,BFR)
      AFR = .FALSE.
10    CONTINUE
      RETURN
      END
 
      SUBROUTINE RITZSB3(EK,F,R,DF,RI,JDIAG,A,B,C,NEQ,MR,MR2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
!---- FORM REDUCED STIFF MATRIX AND RHS VECTORS

      DIMENSION EK(*),F(*),R(*),RI(NEQ,*),A(MR2,*),B(*),C(*),JDIAG(*)
     1 ,DF(*)
!---- NOTE MR2 = MRITZ+2. IF OLDFRC = 0, MR2 = MRITZ + 1
!----  FIRST FORM REDUCED RHS VECTORS
      DO 10 I=1,MR2
      DO 5 J=1,NEQ
      DF(J) = RI(J,I)
5     CONTINUE
      B(I) = DOT(DF,F,NEQ)
      C(I) = DOT(DF,R,NEQ)
10    CONTINUE
!---- NOW FORM REDUCED STIFF MATRIX
      DO 20 J = 1,MR2
      CALL PZERO(DF,NEQ)
      CALL PROMUL(EK,RI(1,J),DF,JDIAG,NEQ)
      DO 30 I=1,MR2
      A(I,J) = DOT(RI(1,I),DF,NEQ)
30    CONTINUE
20    CONTINUE
      RETURN
      END

      SUBROUTINE RITZSB4(A,B,C,DELD,DELPROP,MR,MR2,MRVAR,FLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- SOLVE REDUCED SYSTEM OF EQNS

      LOGICAL FLAG
      DIMENSION A(MR2,*),B(*),C(*),DELD(*)
      MR22 = MR + 2
      IF(FLAG) THEN
!---- THE VARIABLE # MRVAR HAS BEEN SPECIFIED FOR SPECIAL CONTROL
!---- FIRST SWITCH COL # MRVAR AND RHS VECTOR B(I)
      DO 20 I = 1,MR2
      DUM = A(I,MRVAR)
      A(I,MRVAR) = -B(I)
      B(I) = -DUM
20    CONTINUE
      END IF
      IF(MR22.EQ.MR2) THEN
      DO 10 I = 1,MR2
      B(I) = B(I)*DELPROP + C(I)
10    CONTINUE
      ELSE
      DO 12 I =1,MR2
      B(I) = B(I)*DELPROP
12    CONTINUE
      END IF 
      CALL SOLVE(A,B,MR2,1)
      DO 15 I=1,MR2
      DELD(I) = B(I)
15    CONTINUE
      IF(MR22.NE.MR2) DELD(MR22) = 0.D0
      IF(.NOT.FLAG) THEN
      DELD(MR22+1) = DELPROP
      ELSE
      DELD(MR22+1) = B(MRVAR)
      DELD(MRVAR) = DELPROP
      END IF
      RETURN
      END

      SUBROUTINE RITZSB5(DR,R,RI,DELD,PROP,PROPOL,MR,MR2,NEQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- RECONSTRUCT GLOBAL NODAL DISPL VECTOR

      DIMENSION DR(*),RI(NEQ,*),DELD(*),R(*),PROP(7),PROPOL(7)
!---- KEEP INITIAL OUT-OF-BALANCE FORCES FOR NORM CALCULATION
      MR22 = MR + 2
      DO 5 I = 1,NEQ
      R(I) = R(I) + DELD(MR22+1)*DR(I)
5     CONTINUE
!---- NOW COMPUTE INCR NODAL DISPL VECTOR
      CALL PZERO(DR,NEQ)
      DO 10 I =1,NEQ
      DO 15 J =1,MR2
      DR(I) = DR(I) + RI(I,J)*DELD(J)
15    CONTINUE
10    CONTINUE
      PROP(1) = PROPOL(1) + DELD(MR22+1)
      RETURN
      END 

      SUBROUTINE RITZSB6(U,DELD,NDF,MSET,MR,MRVAR,DELPROP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- AUTO CONTROL OF RITZ VARIABLE FOR STABILIZATION 
!---- IDENTIFY VARIABLE TO BE STABILIZED BASED ON WHICH ONE HAD THE
!---- FASTEST GROWTH RATE IN THE PREVIOUS TIME STEP. PRESCRIBE THE SAME
!---- DISPL INCREMENT AS IN THE PREV STEP FOR THAT VARIABLE
      DIMENSION U(*),DELD(*)
      COMMON /PRTSET/ NSET(9,201)
      DATA TOL /1.0D-08/
      MR1 = MR/NDF
      DISPNR = 0.D0
      DO 10 I=1,MR1
      N = NSET(MSET,I+1)
      DO 15 J=1,NDF
      IJ = (I-1)*NDF + J
      NJ = (N-1)*NDF + J
      TOTDSP = U(NJ)
      IF(DABS(TOTDSP).LE.TOL) GO TO 15
      VAR = DABS(DELD(IJ)/TOTDSP)
      IF(VAR.GT.DISPNR) THEN
      DISPNR = VAR
      MRVAR = IJ
      DELPROP = DELD(IJ)
      END IF
15    CONTINUE
10    CONTINUE
      RETURN
      END

      SUBROUTINE RITZSB71(A,B,C,DELD,U,ID,DELPROP,NDF,MR,MR2,IMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- SPECIAL CONTROL OF RITZ VARIABLES FOR COHESIVE ZONE MODELS
!---- SOLVE REDUCED SYSTEM OF EQNS

      COMMON /COHES/ NINTND, INTND(2,100), ALPAA, DLTAA, SIGMXX,
     1 XLNTND(100),ANGINT(100), CPINT(2,100),
     2 XLN(100), ISTAT(100)
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      DIMENSION A(MR2,*),B(*),C(*),DELD(*),U(NDF,*),ID(NDF,*)
      DIMENSION Q(2,2),AA(2,4),QA(2,4),BB(2),CC(4)
      DATA TOL /1.0D-02/
!---- CALCULATE UTD,UND,ALAMDA FOR NODE TO BE STABILIZED
      ALMAX = 0.D0
      DELNC=DLTAA
      DELTC=DLTAA/ALPAA
      L =INTND(1,IMAX)
      L0=INTND(2,IMAX)
!____ L & L0 are global intf nodes referred to material 1 and 2
!____ For global node "L", form the rotation matx
      Q(1,1) =DCOS(ANGINT(IMAX))
      Q(1,2) =DSIN(ANGINT(IMAX))
      Q(2,1) = -Q(1,2)
      Q(2,2) = Q(1,1)
!____ Calculate UT and UN from relative displacemet UX and UY
!____ between nodes "L" and "L0".
      UT =Q(1,1)*(U(1,L)-U(1,L0))+Q(1,2)*(U(2,L)-U(2,L0))
      UN =Q(2,1)*(U(1,L)-U(1,L0))+Q(2,2)*(U(2,L)-U(2,L0))
      IF(UN.LT.0.D0) UN = 0.D0
      UTD =UT/DELTC
      UND =UN/DELNC
      ALAMDA=DSQRT(UTD*UTD+UND*UND)
      ALMAX = ALAMDA
      UTM = UT
      UNM = UN
      IF(ALMAX.EQ.0.D0) THEN   
      WRITE(6,2002)
2002  FORMAT(5X,'********ERROR IN INTERFACE STABILIZATION',/,
     1       5x,'LAMDA FOR INTF NODE TO BE STABILIZED IS ZERO')
      STOP
      END IF

!---- FORM CONSTRAINT EQN BASED ON PRESCRIBING LAMDADOT FOR ABOVE NODE-PAIR
      BB(1) = UTM/(DELTC*DELTC*ALMAX)
      BB(2) = UNM/(DELNC*DELNC*ALMAX)
      DO 15 I=1,2
      DO 15 J=1,4
      AA(I,J) = 0.D0
      QA(I,J) = 0.D0
15    CONTINUE
      AA(1,1) = 1.D0
      AA(1,3) = -1.D0
      AA(2,2) = 1.D0
      AA(2,4) = -1.D0
      Q(1,1) =DCOS(ANGINT(IMAX))
      Q(1,2) =DSIN(ANGINT(IMAX))
      Q(2,1) = -Q(1,2)
      Q(2,2) = Q(1,1)
      DO 20 I=1,2
      DO 20 J=1,4
      DO 20 K=1,2
      QA(I,J) = QA(I,J) + Q(I,K)*AA(K,J)
20    CONTINUE
      DO 25 I=1,4
      CC(I) = 0.D0
      DO 25 K=1,2
      CC(I) = CC(I) + BB(K)*QA(K,I)
25    CONTINUE

!----------------------------------------------------
!     write(6,3000) (bb(i),i=1,2)
3000  format(5x,'bb',2e13.5)
!     write(6,3001) (cc(i),i=1,4)
3001  format(5x,'cc',4e13.5)
!------------------------------------------------------------
!---- COLS OF [A] TO BE ALTERED ARE KK = 1,2,3,4
      KK = 1
      IF((DABS(CC(1)).LT.1.0D-12).AND.(DABS(CC(2)).LT.1.0D-12)) THEN
      WRITE(6,2001)
2001  FORMAT(5X,'ERROR IN CONTROLLING LAMDA. CC(1).AND.CC(2) = 0')
      STOP
      END IF
      IF(DABS(CC(1)).GT.DABS(CC(2))) THEN
      IOP = 1
      ELSE
      IOP = 2
      END IF
!----------------------------------------------------------------
!     write(6,3002) kk,iop,mr2
!3002  format(5x,'kk=',i3,2x,'iop=',i3,2x,'mr2=',i3,/,
!    1 5x,'A matrix before modification')
!     write(6,3003) ((a(i,j),i=1,mr2),j=1,mr2)
3003  format(9e13.5)
!     write(6,3004)
3004  format(5x,'B vector before modification')
!     write(6,3003) (b(i),i=1,mr2)
!     write(6,3005)
3005  format(5x,'C vector before modification')
!     write(6,3003) (c(i),i=1,mr2)
!-------------------------------------------------------------
      IF(IOP.EQ.1) THEN
!---- FIRST SWITCH KKTH COL OF [A] AND RHS VECTOR B
      DO 30 I=1,MR2
      DUM = A(I,KK)
      A(I,KK) = -B(I)
      B(I) = -DUM/CC(1)
!---- NOW MODIFY (K+1), (K+2) AND (K+3) COLS OF [A]
      A(I,KK+1) = A(I,KK+1) - DUM*CC(2)/CC(1)
      A(I,KK+2) = A(I,KK+2) - DUM*CC(3)/CC(1)
      A(I,KK+3) = A(I,KK+3) - DUM*CC(4)/CC(1)
30    CONTINUE
      ELSE
!---- FIRST SWITCH (K+1)TH COL OF [A] AND RHS VECTOR B
      DO 35 I=1,MR2
      DUM = A(I,KK+1)
      A(I,KK+1) = -B(I)
      B(I) = -DUM/CC(2)
!---- NOW MODIFY K, (K+2) AND (K+3) COLS OF [A]
      A(I,KK) = A(I,KK) - DUM*CC(1)/CC(2)
      A(I,KK+2) = A(I,KK+2) - DUM*CC(3)/CC(2)
      A(I,KK+3) = A(I,KK+3) - DUM*CC(4)/CC(2)
35    CONTINUE
      END IF
!---- NOW GET TOTAL RHS VECTOR
      MR22 = MR + 2
      IF(MR22.EQ.MR2) THEN
      DO 40 I = 1,MR2
      B(I) = B(I)*DELPROP + C(I)
40    CONTINUE
      ELSE
      DO 42 I =1,MR2
      B(I) = B(I)*DELPROP
42    CONTINUE
      END IF 

!---- NOW WE GOT TO MODIFY [A] BY ZEROING ROWS AND COLS (EXCEPT DIAG)
!---- CORRESP TO DOFS WITH FIXED DISPLS
      IF((ID(1,L).NE.0).AND.(IOP.EQ.2)) THEN 
      DO 50 IM=1,MR2
      A(IM,1) = 0.D0
      A(1,IM) = 0.D0
50    CONTINUE
      B(1) = 0.D0
      A(1,1) = 1.D0
      END IF
      IF((ID(2,L).NE.0).AND.(IOP.EQ.1)) THEN 
      DO 51 IM=1,MR2
      A(IM,2) = 0.D0
      A(2,IM) = 0.D0
51    CONTINUE
      B(2) = 0.D0
      A(2,2) = 1.D0
      END IF
      IF(ID(1,L0).NE.0) THEN 
      DO 52 IM=1,MR2
      A(IM,3) = 0.D0
      A(3,IM) = 0.D0
52    CONTINUE
      B(3) = 0.D0
      A(3,3) = 1.D0
      END IF
      IF(ID(2,L0).NE.0) THEN 
      DO 53 IM=1,MR2
      A(IM,4) = 0.D0
      A(4,IM) = 0.D0
53    CONTINUE
      B(4) = 0.D0
      A(4,4) = 1.D0
      END IF

!---- SOLVE FOR DELDOTS
!--------------------------------------------------------------
!     write(6,3006)
3006  format(5x,'A, B, C before entering SOLVE')
!     write(6,*) ((a(i,j),i=1,mr2),j=1,mr2)
!     write(6,*) (b(i),i=1,mr2)
!     write(6,*) (c(i),i=1,mr2)
!-----------------------------------------------------------
      CALL SOLVE(A,B,MR2,1)
      DO 60 I=1,MR2
      DELD(I) = B(I)
60    CONTINUE
      IF(MR22.NE.MR2) DELD(MR22) = 0.D0
!-----------------------------------------------------
!     write(6,3007)
3007  format(5x,'deld obtained from solve')
!     write(6,*) (deld(i),i=1,mr2)
!---------------------------------------------

!---- SWITCH BACK DELDOTS
      IF(IOP.EQ.1) THEN
      DELD(MR22+1) = B(KK)
      DELD(KK) = DELPROP - CC(2)*DELD(KK+1) - CC(3)*DELD(KK+2)
     1 - CC(4)*DELD(KK+3)
      DELD(KK) = DELD(KK)/CC(1)
      ELSE
      DELD(MR22+1) = B(KK+1)
      DELD(KK+1) = DELPROP - CC(1)*DELD(KK) - CC(3)*DELD(KK+2)
     1 - CC(4)*DELD(KK+3)
      DELD(KK+1) = DELD(KK+1)/CC(2)
      END IF 
!-----------------------------------------------------
!     write(6,3008)
3008  format(5x,'deld after modification')
!     write(6,3003) (deld(i),i=1,mr22+1)
!---------------------------------------------
      RETURN
      END

      SUBROUTINE RITZSB7(A,B,C,DELD,U,ID,DELPROP,NDF,MR,MR2,IMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- SPECIAL CONTROL OF RITZ VARIABLES FOR COHESIVE ZONE MODELS
!---- WITH ONLY NORMAL SEPARATION CAPABILITY
!---- SOLVE REDUCED SYSTEM OF EQNS

      COMMON /COHES/ NINTND, INTND(2,100), ALPAA, DLTAA, SIGMXX,
     1 XLNTND(100),ANGINT(100), CPINT(2,100),
     2 XLN(100), ISTAT(100)
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      DIMENSION A(MR2,*),B(*),C(*),DELD(*),U(NDF,*),ID(NDF,*)
      DIMENSION CC(2)
      DATA TOL /1.0D-02/
!---- CALCULATE UND FOR NODE TO BE STABILIZED
      DELNC=DLTAA
      L =INTND(1,IMAX)
!____ L is global intf node referred to material 1
!---- FORM CONSTRAINT EQN BASED ON PRESCRIBING LAMDADOT FOR ABOVE NODE
      CC(1) = -DSIN(ANGINT(IMAX))/DELNC
      CC(2) = DCOS(ANGINT(IMAX))/DELNC
!---- COLS OF [A] TO BE ALTERED ARE KK = 1,2
      KK = 1
      IF((DABS(CC(1)).LT.1.0D-12).AND.(DABS(CC(2)).LT.1.0D-12)) THEN
      WRITE(6,2001)
2001  FORMAT(5X,'ERROR IN CONTROLLING LAMDA. CC(1).AND.CC(2) = 0')
      STOP
      END IF
      IF(DABS(CC(1)).GT.DABS(CC(2))) THEN
      IOP = 1
      ELSE
      IOP = 2
      END IF
      IF(IOP.EQ.1) THEN
!---- FIRST SWITCH KKTH COL OF [A] AND RHS VECTOR B
      DO 30 I=1,MR2
      DUM = A(I,KK)
      A(I,KK) = -B(I)
      B(I) = -DUM/CC(1)
!---- NOW MODIFY (K+1) COL OF [A]
      A(I,KK+1) = A(I,KK+1) - DUM*CC(2)/CC(1)
30    CONTINUE
      ELSE
!---- FIRST SWITCH (K+1)TH COL OF [A] AND RHS VECTOR B
      DO 35 I=1,MR2
      DUM = A(I,KK+1)
      A(I,KK+1) = -B(I)
      B(I) = -DUM/CC(2)
!---- NOW MODIFY KTH COL OF [A]
      A(I,KK) = A(I,KK) - DUM*CC(1)/CC(2)
35    CONTINUE
      END IF
!---- NOW GET TOTAL RHS VECTOR
      MR22 = MR + 2
      IF(MR22.EQ.MR2) THEN
      DO 40 I = 1,MR2
      B(I) = B(I)*DELPROP + C(I)
40    CONTINUE
      ELSE
      DO 42 I =1,MR2
      B(I) = B(I)*DELPROP
42    CONTINUE
      END IF 

!---- NOW WE GOT TO MODIFY [A] BY ZEROING ROWS AND COLS (EXCEPT DIAG)
!---- CORRESP TO DOFS WITH FIXED DISPLS
      IF((ID(1,L).NE.0).AND.(IOP.EQ.2)) THEN 
      DO 50 IM=1,MR2
      A(IM,1) = 0.D0
      A(1,IM) = 0.D0
50    CONTINUE
      B(1) = 0.D0
      A(1,1) = 1.D0
      END IF
      IF((ID(2,L).NE.0).AND.(IOP.EQ.1)) THEN 
      DO 51 IM=1,MR2
      A(IM,2) = 0.D0
      A(2,IM) = 0.D0
51    CONTINUE
      B(2) = 0.D0
      A(2,2) = 1.D0
      END IF

!---- SOLVE FOR DELDOTS
      CALL SOLVE(A,B,MR2,1)
      DO 60 I=1,MR2
      DELD(I) = B(I)
60    CONTINUE
      IF(MR22.NE.MR2) DELD(MR22) = 0.D0

!---- SWITCH BACK DELDOTS
      IF(IOP.EQ.1) THEN
      DELD(MR22+1) = B(KK)
      DELD(KK) = DELPROP - CC(2)*DELD(KK+1)
      DELD(KK) = DELD(KK)/CC(1)
      ELSE
      DELD(MR22+1) = B(KK+1)
      DELD(KK+1) = DELPROP - CC(1)*DELD(KK)
      DELD(KK+1) = DELD(KK+1)/CC(2)
      END IF 
      RETURN
      END

      SUBROUTINE RITZSB81(U,PROP,NDF,IMAX,MRVAR,DELPROP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- SPECIAL CONTROL OF RITZ VARIABLES FOR COHESIVE ZONE MODELS
!---- FIRST IDENTIFY INTERFACE NODE-PAIR TO BE STABILIZED

      COMMON /COHES/ NINTND, INTND(2,100), ALPAA, DLTAA, SIGMXX,
     1 XLNTND(100),ANGINT(100), CPINT(2,100),
     2 XLN(100), ISTAT(100)
      COMMON /PRTSET/ NSET(9,201)
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      DIMENSION U(NDF,*),Q(2,2),PROP(7)
      DATA DEL2H/0.47/
!     DATA DEL2H/0.13/


!____ Loop over all the nodes on the interface 
      ALMAX = 0.D0
      IMAX = 1
      DELNC=DLTAA
      DELTC=DLTAA/ALPAA
      DO 10 I=1,NINTND
      IF(ISTAT(I) .EQ. 2) GO TO 10 
      L =INTND(1,I)
      L0=INTND(2,I)
!____ L & L0 are global intf nodes referred to material 1 and 2
!____ For global node "L", form the rotation matx
      Q(1,1) =DCOS(ANGINT(I))
      Q(1,2) =DSIN(ANGINT(I))
      Q(2,1) = -Q(1,2)
      Q(2,2) = Q(1,1)
!____ Calculate UT and UN from relative displacemet UX and UY
!____ between nodes "L" and "L0".
      UT =Q(1,1)*(U(1,L)-U(1,L0))+Q(1,2)*(U(2,L)-U(2,L0))
      UN =Q(2,1)*(U(1,L)-U(1,L0))+Q(2,2)*(U(2,L)-U(2,L0))
      UTD =UT/DELTC
      UND =UN/DELNC
!---- FOR INTERPENETRATING INTERFACE NODES SKIP FOLL
      IF(UND.LT.0.D0) THEN
      ALAMDA = DABS(UTD)
!     GO TO 11
      ELSE
      ALAMDA=DSQRT(UTD*UTD+UND*UND)
      END IF
      IF(ALAMDA.GT.ALMAX) THEN      
      ALMAX = ALAMDA
      UTM = UT
      UNM = UN
      IMAX = I
      END IF
11    CONTINUE
!-----------------------------------------------------------
      write(25,3001) time,I,L,L0,ISTAT(I),UTD,UND,ALAMDA,XLN(I)
3001  format(e13.5,3i4,i2,4e13.5)
!------------------------------------------------------
10    CONTINUE
      IF(ALMAX.LE.DEL2H) THEN
      IF(PROP(1).LT.PROP(3)) PROP(3) = PROP(1)
      MRVAR = 0
      ELSE
      MRVAR = 1
      DELPROP = 1.D0
      IF(ALMAX.LT.0.16) THEN
      DELPROP = 0.1
      END IF
      IF((ALMAX.GT.0.48).AND.(ALMAX.LT.0.51)) THEN
      DELPROP = 0.4
      END IF
      PROP(3) = PROP(1)
      END IF
      IF(PROP(1).GT.PROP(2)) PROP(2) = PROP(1)
      IF(MRVAR.EQ.0) THEN
      WRITE(6,2000) INTND(1,IMAX),INTND(2,IMAX),ALMAX,PROP(1),TIME
2000  FORMAT(2X,'CONTROLLING LOAD INCREMENT THRO GLOBAL INTF NODES',
     1 2I5,' WITH LAMDA =',E13.5,' LOAD =',
     2 E13.5,' AT TIME =',E13.5)
      ELSE
      WRITE(6,2001) INTND(1,IMAX),INTND(2,IMAX),ALMAX,PROP(1),TIME
2001  FORMAT(5X,'CONTROLLING LAMDA INCREMENT OF GLOBAL INTF NODES',
     1 2I5,' WITH LAMDA =',E13.5,' LOAD =',
     2 E13.5,' AT TIME =',E13.5)
      IF(ALMAX.EQ.0.D0) THEN   
      WRITE(6,2002)
2002  FORMAT(5X,'********ERROR IN INTERFACE STABILIZATION',/,
     1       5x,'LAMDA FOR INTF NODE TO BE STABILIZED IS ZERO')
      STOP
      END IF
      END IF
!---- RESET DEFINITION OF SET #1
      NSET(1,1) = 2
      NSET(1,2) = INTND(1,IMAX)
      NSET(1,3) = INTND(2,IMAX)
      RETURN
      END

      SUBROUTINE RITZSB8(U,PROP,NDF,IMAX,MRVAR,DELPROP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!---- SPECIAL CONTROL OF RITZ VARIABLES FOR COHESIVE ZONE MODELS
!---- WITH NORMAL SEPARATION CAPABILITY ONLY
!---- FIRST IDENTIFY INTERFACE NODE TO BE STABILIZED

      COMMON /COHES/ NINTND, INTND(2,100), ALPAA, DLTAA, SIGMXX,
     1 XLNTND(100),ANGINT(100), CPINT(2,100),
     2 XLN(100), ISTAT(100)
      COMMON /PRTSET/ NSET(9,201)
      COMMON /TDATA/ TIME,DT,BETA,GAMMA
      DIMENSION U(NDF,*),PROP(7)
!     DATA DEL2H/0.47/
      DATA DEL2H/0.13/

!____ Loop over all the nodes on the interface 
      ALMAX = 0.D0
      IMAX = 1
      DELNC=DLTAA
      DO 10 I=1,NINTND
      IF(ISTAT(I) .EQ. 2) GO TO 10 
      L =INTND(1,I)
!____ L is global intf node referred to material 1
!____ For global node "L", form the rotation matx
      UN = -DSIN(ANGINT(I))*U(1,L) + DCOS(ANGINT(I))*U(2,L)
      UND =UN/DELNC
!---- FOR INTERPENETRATING INTERFACE NODES SKIP FOLL
      IF(UND.LT.0.D0) THEN
      ALAMDA = 0.D0
      GO TO 11
      ELSE
      ALAMDA=UND
      END IF
      IF(ALAMDA.GT.ALMAX) THEN      
      ALMAX = ALAMDA
      UNM = UN
      IMAX = I
      END IF
11    CONTINUE
!-----------------------------------------------------------
      write(25,3001) time,I,L,ISTAT(I),UND,ALAMDA,XLN(I)
3001  format(e13.5,2i4,i2,3e13.5)
!------------------------------------------------------
10    CONTINUE
      IF(ALMAX.LE.DEL2H) THEN
      IF(PROP(1).LT.PROP(3)) PROP(3) = PROP(1)
      MRVAR = 0
      ELSE
      MRVAR = 1
      DELPROP = 1.D0
      IF(ALMAX.LT.0.16) THEN
      DELPROP = 0.1
      END IF
      IF((ALMAX.GT.0.48).AND.(ALMAX.LT.0.51)) THEN
      DELPROP = 0.4
      END IF
      PROP(3) = PROP(1)
      END IF
      IF(PROP(1).GT.PROP(2)) PROP(2) = PROP(1)
      IF(MRVAR.EQ.0) THEN
      WRITE(6,2000) INTND(1,IMAX),ALMAX,PROP(1),TIME
2000  FORMAT(2X,'CONTROLLING LOAD INCREMENT THRO GLOBAL INTF NODE',
     1 I5,' WITH LAMDA =',E13.5,' LOAD =',
     2 E13.5,' AT TIME =',E13.5)
      ELSE
      WRITE(6,2001) INTND(1,IMAX),ALMAX,PROP(1),TIME
2001  FORMAT(5X,'CONTROLLING LAMDA INCREMENT OF GLOBAL INTF NODE',
     1 I5,' WITH LAMDA =',E13.5,' LOAD =',
     2 E13.5,' AT TIME =',E13.5)
      IF(ALMAX.EQ.0.D0) THEN   
      WRITE(6,2002)
2002  FORMAT(5X,'********ERROR IN INTERFACE STABILIZATION',/,
     1       5x,'LAMDA FOR INTF NODE TO BE STABILIZED IS ZERO')
      STOP
      END IF
      END IF
!---- RESET DEFINITION OF SET #1
      NSET(1,1) = 1
      NSET(1,2) = INTND(1,IMAX)
      RETURN
      END
